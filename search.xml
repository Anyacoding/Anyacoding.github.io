<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Git常用命令</title>
      <link href="/archives/caff8000.html"/>
      <url>/archives/caff8000.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-初始化本地仓库"><a href="#1-初始化本地仓库" class="headerlink" title="1.初始化本地仓库"></a>1.初始化本地仓库</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="keyword">init</span></span><br></pre></td></tr></table></figure><h2 id="2-确认工作树和索引的状态"><a href="#2-确认工作树和索引的状态" class="headerlink" title="2.确认工作树和索引的状态"></a>2.确认工作树和索引的状态</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure><h2 id="3-将文件添加到暂存区"><a href="#3-将文件添加到暂存区" class="headerlink" title="3.将文件添加到暂存区"></a>3.将文件添加到暂存区</h2><p>在 [file] 指定加入暂存区的文件, 用空格分隔多个文件。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git add [file]<span class="operator">..</span></span><br><span class="line">## e.g.</span><br><span class="line">$ git add <span class="type">README</span>.md</span><br><span class="line">$ git add <span class="type">README</span>.md main.cpp</span><br></pre></td></tr></table></figure><h2 id="4-将所有新文件、更改过的文件添加到暂存区"><a href="#4-将所有新文件、更改过的文件添加到暂存区" class="headerlink" title="4.将所有新文件、更改过的文件添加到暂存区"></a>4.将所有新文件、更改过的文件添加到暂存区</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git add .</span><br></pre></td></tr></table></figure><h2 id="5-提交更改-将暂存区内容添加到本地仓库中"><a href="#5-提交更改-将暂存区内容添加到本地仓库中" class="headerlink" title="5.提交更改, 将暂存区内容添加到本地仓库中"></a>5.提交更改, 将暂存区内容添加到本地仓库中</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit <span class="operator">-</span>m <span class="string">&quot;first commit&quot;</span></span><br></pre></td></tr></table></figure><h2 id="6-查看更改"><a href="#6-查看更改" class="headerlink" title="6.查看更改"></a>6.查看更改</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br></pre></td></tr></table></figure><h2 id="7-添加一个远程存储库"><a href="#7-添加一个远程存储库" class="headerlink" title="7.添加一个远程存储库"></a>7.添加一个远程存储库</h2><p>请使用remote指令添加远程数据库。在 [name] 处输入远程数据库名称，在 [url] 处指定远程数据库的URL。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add [name] [url]</span><br><span class="line">## e.g.</span><br><span class="line">$ git remote add origin https:<span class="comment">//[your_space_id].backlogtool.com/git/[your_project_key]/tutorial.git</span></span><br></pre></td></tr></table></figure><blockquote><p><em><strong>tips:</strong></em> 执行推送或者拉取的时候，如果省略了远程数据库的名称，则默认使用名为”origin“的远程数据库。因此一般都会把远程数据库命名为origin。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git常用命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="/archives/bb0c7ac5.html"/>
      <url>/archives/bb0c7ac5.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>想起很久之前曾在Leetcode刷到过一道很经典的归并排序的题目，虽然题目不难，但实现起来并没有想象中那么容易。为了方便日后查阅，在这里特地记录一下</p><h2 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p><p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p><ul><li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</li><li>自下而上的迭代；</li></ul><p>为了代码的简洁，我这里采用的是递归的写法。</p><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><blockquote><p><em><strong>首先感谢<a href="https://www.cnblogs.com/chengxiao/p/6194356.html">图解排序算法(四)之归并排序</a>这篇文章的作者，对于归并排序的流程他完成了几幅很精美简洁的流程图，在这里分享给大家</strong></em></p></blockquote><p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/202207042134907.png"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r, vector&lt;<span class="type">int</span>&gt;&amp; temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l + <span class="number">1</span> &gt;= r) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// divide</span></span><br><span class="line">    <span class="type">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(nums, l, m, temp);</span><br><span class="line">    <span class="built_in">merge_sort</span>(nums, m, r, temp);</span><br><span class="line">    <span class="comment">// conquer</span></span><br><span class="line">    <span class="type">int</span> p = l, q = m, i = l;</span><br><span class="line">    <span class="keyword">while</span> (p &lt; m || q &lt; r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q &gt;= r || (p &lt; m &amp;&amp; nums[p] &lt;= nums[q])) &#123;</span><br><span class="line">            temp[i++] = nums[p++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[i++] = nums[q++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = l; i &lt; r; ++i) &#123;</span><br><span class="line">        nums[i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实战指路"><a href="#实战指路" class="headerlink" title="实战指路"></a>实战指路</h2><blockquote><p><a href="https://leetcode-cn.com/problems/sort-list/"><em><strong>Leetcode 148. Sort List (Medium)</strong></em></a></p></blockquote><p>“<em><strong>学会一种算法的最好方法就是去使用它。</strong></em>“<br><em><strong>Get your hand dirty！</strong></em></p><p>这里给出我的实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> ListNode* List;</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergesort</span>(head);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">List <span class="title">mergesort</span><span class="params">(List head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果第一或第二个结点是空结点，则不用归并，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        List fast, slow, fasttp, l, r;<span class="comment">//设定快慢指针来找中间结点；</span></span><br><span class="line">        fast = slow = head;</span><br><span class="line">        fasttp = head-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (fasttp != <span class="literal">NULL</span> &amp;&amp; fasttp-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fasttp = fasttp-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时slow-&gt;next即为中间结点</span></span><br><span class="line">        <span class="comment">//对右边进行归并</span></span><br><span class="line">        r = <span class="built_in">mergesort</span>(slow-&gt;next);</span><br><span class="line">        <span class="comment">//一个链表结束的标志是nullptr，所以这里进行cut操作，否则会出现一个循环的死</span></span><br><span class="line">        slow-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        l = <span class="built_in">mergesort</span>(head);</span><br><span class="line">        <span class="comment">//最后将左右两段进行一个合并</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(l, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">List <span class="title">merge</span><span class="params">(List l, List r)</span> </span>&#123;</span><br><span class="line">        List temphead = <span class="keyword">new</span> ListNode;</span><br><span class="line">        List p = temphead;</span><br><span class="line">        <span class="keyword">while</span> (l &amp;&amp; r) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l-&gt;val &lt;= r-&gt;val) &#123;</span><br><span class="line">                p-&gt;next = l;</span><br><span class="line">                l = l-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p-&gt;next = r;</span><br><span class="line">                r = r-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当左边有剩余时</span></span><br><span class="line">        <span class="keyword">if</span> (l != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            p-&gt;next = l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当右边有剩余时</span></span><br><span class="line">        <span class="keyword">if</span> (r != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            p-&gt;next = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temphead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 板子 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++内存对齐问题</title>
      <link href="/archives/af823184.html"/>
      <url>/archives/af823184.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天热心(huaidan)群友在群里出了这样一个问题: <mark class="hl-label pink">请推测出下列代码的输出，在32位系统下.</mark> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> a = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    <span class="built_in">myclass</span>(): arr&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, <span class="built_in">p</span>(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">2</span>]) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">myclass</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    myclass obj; </span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(obj.arr) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(obj.p) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(obj);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我的答案是12 4 25，嘿嘿，我还信心满满的捏。因为我已经注意到了要把虚函数表隐含的那根指针算进去。然而我还是被坑了。</p><mark class="hl-label pink">正确答案如下:</mark> <p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/202207042134912.png"><br>前两个没什么好说的，主要是第三个输出。28是这么来的：<em><strong>28 &#x3D; vptr4 + f4 + c4 + arr12 + p4</strong></em></p><p>如果你没有接下来将要介绍的知识，估计你也会疑惑，为什么char的大小不是1字节而是4字节呢？如果char在这里的大小为1字节，结果将是我所预测的25。</p><p>然而事实却是，一个结构体或类定义完后，其在内存中的存储并不等于其所包含的元素的宽度之和。<br>这就是<em><strong>内存对齐问题</strong></em></p><p>首先感谢<a href="https://blog.csdn.net/liukun321/article/details/6974282">结构体在内存中的对齐规则 - 咕唧咕唧shubo.lk的专栏 - 博客频道 - CSDN.NET</a>这篇文章的作者，正是通过他的博客，我才真正弄懂了内存对齐问题</p><h2 id="原则一"><a href="#原则一" class="headerlink" title="原则一"></a>原则一</h2><p><em><strong>结构体中元素是按照定义顺序一个一个放到内存中去的，但并不是紧密排列的。从结构体存储的首地址开始，每一个元素放置到内存中时，它都会认为内存是以它自己的大小来划分的，因此元素放置的位置一定会在自己宽度的整数倍上开始（以结构体变量首地址为0计算）。</strong></em></p><p>比如我们上面举的例子，首先系统会将虚函数表指针放入第0-3个字节(这里指的时相对地址，即内存开辟的首地址)，这里是另外一个知识了，<em><strong>若一个类中有虚函数，那么他的虚函数表指针将放在类的开头</strong></em>；然后在存放float型变量时，会以4个字节为单位进行存储，也就是在第4-7个字节；然后是放入char型变量，每个char以1个字节为单位进行存储，也就是放在第8个字节；然后是放入int型数组，这个数组有3个元素，也就是将要放入3个int，每个int以4个字节为单位进行存储，由于前三个四字节模块已经有数据，所以这个数组会被存放在第12-23个字节；最后是指针p，在32位系统下指针的宽度为4个字节，所以他会被放在第24-27个字节。</p><mark class="hl-label pink">整体存储示意图如下所示:</mark> <p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/202207042134914.png"><br>到这里还没完，让我们试着把float改成double试试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> a = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    <span class="built_in">myclass</span>(): arr&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, <span class="built_in">p</span>(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">2</span>]) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">myclass</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    myclass obj; </span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(obj.arr) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(obj.p) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(obj);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了上面介绍的原则一，我们不难算出obj的大小为 <em><strong>36 &#x3D; 8 + 8 + 4 + 12 + 4</strong></em>，和上面计算过程中唯一的区别是我们的虚函数表指针由于double的对齐问题，被看作了一个8字节大小的单元。</p><p>然而事实却不是这样。<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/202207042134913.png"><br>而这就引出了我们的第二原则。</p><h2 id="原则二"><a href="#原则二" class="headerlink" title="原则二"></a>原则二</h2><p><em><strong>在经过第一原则分析后，检查计算出的存储单元是否为所有元素中最宽的元素的长度的整数倍，是，则结束；若不是，则补齐为它的整数倍。</strong></em></p><p>在上面这个例子中，我们分析完后的存储长度为36字节，不是最宽元素double长度的整数倍，因此将36补齐到8的整数倍，也就是40。这样就没问题了。</p><mark class="hl-label pink">其存储示意图如下所示:</mark> <p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/202207042134915.png"><br>掌握了这两个原则，就足以分析所有数据存储的对齐问题了。快去找几个例子试试吧！</p><hr><p>这里进行一个补充：由于static成员并不属于类的实例对象，所以在计算的时候请注意不要把static成员考虑进来捏~</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++内存对齐问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于C语言scanf函数吃人事件</title>
      <link href="/archives/66d72fbf.html"/>
      <url>/archives/66d72fbf.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大一的时候刚刚接触c语言，使用scanf函数总是会莫名出现各种奇怪的输入问题，想想还真是踩了很多坑捏呜呜。例如输入数据时，会发现若%d后面加了空格之后按下回车键控制台没有响应，这其实就是吃空白行为。</p><p>给变量赋值实际上需要从缓冲区提取合适的数据到变量中，而缓冲区的数据其实是由我们的键盘来输入的。</p><mark class="hl-label pink">举个例子:</mark> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;x = %d\ny = %d&quot;</span>, x, y);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面这段代码，我们可以有两种输入方法。一种是输入x的值，然后空格，然后输入y的值</p><p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/KMI5DOV4BC08U4XH.png"></p><p>另一种是输入x的值，回车，然后输入y的值</p><p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/T_6PKH61Z9A@FP7SYO5RO.png"></p><p>不难发现，其实两种输入方式的回车和空格都没有被输入到y中，这是我们所期望的。这是因为%d的匹配机制，会不断丢弃空白符(<mark class="hl-label pink">包括回车，空白等</mark> )，直到出现数字字符，然后scanf开始解析数字字符串，再将解析好的数值存入到y中。至此一个%d的匹配工作完成，当然，最后结束输入的时候我们还按了一个回车，这个回车仍然留在缓冲区中没被处理。</p><p>通过上述的实验我们可以知道，%d会自动把缓冲区中数字字符串之前的空白符全部扔掉，也就是恰空白行为。</p><h2 id="关于-d无响应问题"><a href="#关于-d无响应问题" class="headerlink" title="关于%d无响应问题"></a>关于%d无响应问题</h2><p>由于作为一名c语言弱鸡，对于格式化的要求往往非常随意，我在使用%d时常常最后面错误地多加了一个空格，从而导致了输入无法正常结束。也就会发生经典剧情，“<mark class="hl-label pink">明明我们的代码一模一样，为什么我的就运行不了呜呜。</mark> ” 我们需要知道，当%d的匹配工作完成后，%d后面的空格开始工作，空格意味着丢掉所有空白符，因此无论我们输入多少个空格和回车，scanf都不会正常结束。要使scanf函数结束，我们需要输入一个非空白字符，来使得空格吃空白符的工作结束。</p><p>细心的同学应该发现了，其实我们最后输入的那个非空白符任然留在缓冲区中，没有被处理，在下次输入时就会被事与愿违地读取，我们来看这一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d &quot;</span>, &amp;x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x = %d\n&quot;</span>, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/628H_N7IKDHWOT8T.png"></p><p>不建议在%d后面加入空格捏</p><h2 id="吃空白的其他烹饪方式"><a href="#吃空白的其他烹饪方式" class="headerlink" title="吃空白的其他烹饪方式"></a>吃空白的其他烹饪方式</h2><p>由于%d本身就会吃掉整形数前面的所有空白符，所以在%d前面加不加空格都无所谓捏。但是对于字符%c来说情况就完全不同了，由于空白符本身也是一种字符，所以%c会错误地把多余地空格以及回车等东东读入捏。</p><p>我们看下面的一组例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span> y = <span class="string">&#x27;&#x27;;</span></span><br><span class="line"><span class="string">  scanf(&quot;%d&quot;, &amp;x);</span></span><br><span class="line"><span class="string">  scanf(&quot;%c&quot;, &amp;y);</span></span><br><span class="line"><span class="string">  printf(&quot;x = %d\ny = %c&quot;, x, y);</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/8NML31TBKRS@ILNK1M2X.png"></p><p>可以明显看到，留在缓冲区中的空格被y读取了。你可以去试试，输入x的值，回车，再输入y的值，缓冲区中的回车同样会被y读取。</p><p>为了达到我们想要的效果，我们可以在%c前面加一个空格，来把缓冲区中多余的空白符吃掉：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span> y = <span class="string">&#x27;&#x27;;</span></span><br><span class="line"><span class="string">  scanf(&quot;%d&quot;, &amp;x);</span></span><br><span class="line"><span class="string">  scanf(&quot; %c&quot;, &amp;y);</span></span><br><span class="line"><span class="string">  printf(&quot;x = %d\ny = %c&quot;, x, y);</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/PDF0ELCJ7H08KQTBO7A.png"></p><p>我们得到了我们想要的效果。</p><p>因此，当我们的输入中不想错误地读取空白字符时，建议你在%c前面加上一个空格。</p><p>对于%s的处理方式，和%c非常相似。%s遇到空白符就会认为这个字符串输入完毕了，且这个空白符及其之后的输入仍然会留在缓冲区中。</p><p>上例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入一串字符：&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;这个字符串为:%s\n&quot;</span>, str);</span><br><span class="line">  gets(str);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;这个字符串为:%s\n&quot;</span>, str);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/WIYCBKZND7_P1HRX.png"><br>这里我用gets函数把留在缓冲区中的内容全都取了出来，结果很显然了</p><p>对于scanf吃空白这一技巧，其实更多的是一种技术细节，比起死记硬背他的用法，更重要的是我们应该理解这背后的原理，这样方能以不变应万变</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
