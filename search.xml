<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PA2实验笔记</title>
      <link href="/archives/81c5e64f.html"/>
      <url>/archives/81c5e64f.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>PA是NJU ICS的课程实验，作为一个非科班的学生，要完成这个实验属实不易，但是在这个过程中我收获到的知识和经验无疑是我求学路上无比宝贵的财富。为了记录下这宝贵的经历，故写此博客记录下我的苦恼与感悟。在这篇博客里我会简单叙述我的思路和踩过的坑。<em><strong>另外特此声明，如果您本身需要独自完成PA实验，为了学术诚信，请自行完成后再参考本博客，今日偷的懒，在未来会加倍偿还！</strong></em></p><h1 id="不停计算的机器"><a href="#不停计算的机器" class="headerlink" title="不停计算的机器"></a>不停计算的机器</h1><p>在PA1中, 我们已经见识到最简单的计算机TRM的工作方式:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  从PC指示的存储器位置取出指令;</span><br><span class="line">  执行指令;</span><br><span class="line">  更新PC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于大部分指令来说, 执行它们都可以抽象成 <em><strong>取指-译码-执行</strong></em> 的指令周期。对于TRM来说，只要内存无限，这个循环就可以一直进行下去，是真正意义上的不停计算的机器。</p><h1 id="RTFSC-友好地阅读源码"><a href="#RTFSC-友好地阅读源码" class="headerlink" title="RTFSC(友好地阅读源码)"></a>RTFSC(友好地阅读源码)</h1><p>我们在PA1中提到:</p><blockquote><p>我们可以看到 <em><strong>cpu_exec()</strong></em> 模拟了CPU的工作方式: 不断执行指令.  <em><strong>fetch_decode_exec_updatepc()</strong></em> 函数  <em><strong>(在nemu&#x2F;src&#x2F;cpu&#x2F;cpu-exec.c中定义)</strong></em> 让CPU执行当前PC指向的一条指令, 然后更新PC.</p></blockquote><p>因此我们只需要弄懂 <em><strong>fetch_decode_exec_updatepc()</strong></em> 的工作原理，就可以很好地完成 <em><strong>取指-译码-执行</strong></em> 的工作了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">fetch_decode_exec_updatepc</span><span class="params">(Decode *s)</span> &#123;</span><br><span class="line">  fetch_decode(s, cpu.pc); <span class="comment">// 取出指令并且译码</span></span><br><span class="line">  s-&gt;EHelper(s);           <span class="comment">// 执行</span></span><br><span class="line">  cpu.pc = s-&gt;dnpc;        <span class="comment">// 更新PC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="取指-instruction-fetch-IF"><a href="#取指-instruction-fetch-IF" class="headerlink" title="取指(instruction fetch, IF)"></a>取指(instruction fetch, IF)</h2><p>如果你跳转到 <em><strong>fetch_decode(s, cpu.pc)</strong></em> 的定义里查看，就会发现这个函数的工作就是把当前的 <em><strong>PC</strong></em> 保存到 <em><strong>s</strong></em> 的成员 <em><strong>pc</strong></em> 和 <em><strong>snpc</strong></em> 中, 其中 <em><strong>s-&gt;pc</strong></em> 就是当前指令的 <em><strong>PC</strong></em>, 而 <em><strong>s-&gt;snpc</strong></em> 则是下一条指令的 <em><strong>PC</strong></em>, 这里的 <em><strong>snpc</strong></em> 是 <em><strong>“static next PC”</strong></em> 的意思。</p><p>而这个函数中的重头戏其实是 <em><strong>isa_fetch_decode()</strong></em> 这个函数调用。<em><strong>isa_fetch_decode()</strong></em> 做的第一件事就是从内存中取指令，这项工作具体由 <em><strong>instr_fetch()</strong></em> 函数来完成。<em><strong>instr_fetch()</strong></em> 会根据你传入的 <em><strong>pc</strong></em> 和期望的字节长度，经过一层转发最终调用 <em><strong>paddr_read()</strong></em> 函数来访问物理内存中的内容。因此取值操作就是一个简单的内存访问而已。并且 <em><strong>instr_fetch()</strong></em> 将返回一个 <em><strong>uint32_t</strong></em> 类型的数据，并将其赋值给 <em><strong>s</strong></em> 指向的 <em><strong>Decode</strong></em> 结构体，这样 *<strong>Decode <em>s</em></strong> 指向的结构体就持有了该条指令的全部信息了，接下来的工作就是解析出该指令的信息。</p><p>调用 <em><strong>instr_fetch()</strong></em> 的时候传入了 <em><strong>s-&gt;snpc</strong></em> 的地址, 因此 <em><strong>instr_fetch()</strong></em> 最后还会根据 <em><strong>len</strong></em> 来更新 <em><strong>s-&gt;snpc</strong></em> , 从而让 <em><strong>s-&gt;snpc</strong></em> 指向下一条指令。</p><p><em><strong>总结下来，取指工作完成了两件事情：</strong></em></p><ul><li><em><strong>s</strong></em> 指向的 <em><strong>Decode</strong></em> 结构体获得当前 <em><strong>pc</strong></em> 所指向的指令</li><li>更新 <em><strong>s-&gt;snpc</strong></em>， 让 <em><strong>s-&gt;snpc</strong></em> 指向下一条指令。</li></ul><p><em><strong>另外很有必要的一件事是清楚 <em><strong>Decode</strong></em> 结构体的内容，具体地：</strong></em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Decode</span> &#123;</span></span><br><span class="line">  <span class="type">vaddr_t</span> pc;   <span class="comment">// 当前指令内存的位置</span></span><br><span class="line">  <span class="type">vaddr_t</span> snpc; <span class="comment">// static next pc</span></span><br><span class="line">  <span class="type">vaddr_t</span> dnpc; <span class="comment">// dynamic next pc</span></span><br><span class="line">  <span class="type">void</span> (*EHelper)(<span class="keyword">struct</span> Decode *); <span class="comment">// 执行指令的函数 </span></span><br><span class="line">  Operand dest, src1, src2;         <span class="comment">// 目标和源1 源2</span></span><br><span class="line">  ISADecodeInfo isa;                <span class="comment">// 实际二进制指令</span></span><br><span class="line">  IFDEF(CONFIG_ITRACE, <span class="type">char</span> logbuf[<span class="number">128</span>]);  <span class="comment">// 此项可暂时忽略</span></span><br><span class="line">&#125; Decode;</span><br></pre></td></tr></table></figure><h2 id="译码-instruction-decode-ID"><a href="#译码-instruction-decode-ID" class="headerlink" title="译码(instruction decode, ID)"></a>译码(instruction decode, ID)</h2><p>译码的目的是得到指令的操作和操作对象, 这主要是通过查看指令的 <em><strong>opcode（操作码）</strong></em> 来决定的。当然不同的 <em><strong>ISA</strong></em> 的 <em><strong>opcode</strong></em> 的位置和组织方式不同，我们需要通过相应的手册来获取这些信息。而我所选择的 <em><strong>ISA</strong></em> 是 <em><strong>RISCV-32</strong></em> , 这是一款年轻开源并且极富潜力的 <em><strong>ISA</strong></em>, 他的所有指令都是32位定长的，这对于我们的译码来说将会提供很大的帮助。</p><p>NEMU使用一种抽象层次更高的译码方式: <em><strong>模式匹配</strong></em>, 可以通过一个模式字符串来指定指令中的 <em><strong>opcode</strong></em>。以我所选的 <em><strong>RISCV-32</strong></em> 举例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def_INSTR_IDTAB(<span class="string">&quot;??????? ????? ????? ??? ????? 01101 11&quot;</span>, U     , lui);</span><br></pre></td></tr></table></figure><p>模式字符串中只允许出现4种字符:</p><ul><li>0表示相应的位只能匹配0</li><li>1表示相应的位只能匹配1</li><li>?表示相应的位可以匹配0或1</li><li>(空格)是分隔符, 只用于提升模式字符串的可读性, 不参与匹配</li></ul><p>其中 <em><strong>def_INSTR_IDTAB</strong></em> 是一个宏，对其进行展开后可以得到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="type">uint32_t</span> key, mask, shift;</span><br><span class="line">  pattern_decode(<span class="string">&quot;??????? ????? ????? ??? ????? 01101 11&quot;</span>, <span class="number">37</span>, &amp;key, &amp;mask, &amp;shift);</span><br><span class="line">  <span class="keyword">if</span> (((s-&gt;isa.instr.val &gt;&gt; shift) &amp; mask) == key) &#123;</span><br><span class="line">    decode_U(s, <span class="number">0</span>);       <span class="comment">// 译码辅助函数，其中第二个参数width是专门为x86这种不定长指令准备的，</span></span><br><span class="line">                          <span class="comment">// 而我选择的RISCV-32其实并不需要第二个参数，所以直接默认都是为0</span></span><br><span class="line">    <span class="keyword">return</span> table_lui(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>对于 <em><strong>pattern_decode</strong></em> 具体如何工作你可以跳转到他的定义去了解，但在这里其实不是重点，重点是经过一系列转换后我们的一段32位的定长指令可以精确匹配到 <em><strong>RISCV-32</strong></em> 的的六种基本指令格式： <em><strong>R、I、S、B、U、J。</strong></em> </p><p>此时指令满足上述宏展开的if语句, 表示匹配到 <em><strong>lui指令</strong></em> 的编码, 因此将会进行进一步的译码操作。</p><p>刚才我们只知道了指令的具体操作(比如 <em><strong>lui指令</strong></em> 是读入一个立即数到寄存器的高位), 但我们还是不知道操作对象(比如立即数是多少, 读入到哪个寄存器)。为了解决这个问题, 代码需要进行进一步的译码工作, 这是通过调用相应的 <em><strong>译码辅助函数(decode helper function)</strong></em> 来完成的。</p><p>译码辅助函数统一通过宏 <em><strong>def_DHelper(在nemu&#x2F;include&#x2F;cpu&#x2F;decode.h中定义)</strong></em> 来定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> def_DHelper(name) void concat(decode_, name) (Decode *s)</span></span><br></pre></td></tr></table></figure><p>请注意，这其实只是为了方便生成多个函数签名，其实是没有函数体的，因为每种指令的的操作对象有可能是立即数也可能是寄存器，关于如何定义函数体是要根据每种指令的类型来定制的。</p><p>每个 <em><strong>译码辅助函数</strong></em> 负责进行一种类型的操作数译码, 把指令中的操作数信息分别记录在译码信息 <em><strong>s</strong></em> 的 <em><strong>dest成员</strong></em> , <em><strong>src1成员</strong></em> 和 <em><strong>src2成员</strong></em> 中, 它们分别代表目的操作数和两个源操作数。</p><p>我们会发现, 类似寄存器和立即数这些操作数, 其实是非常常见的操作数类型. 为了进一步实现 <em><strong>操作数译码</strong></em> 和 <em><strong>指令译码</strong></em> 的解耦, 框架代码对这些操作数的译码进行了抽象封装, 指令译码过程由若干 <em><strong>译码操作数辅助函数(decode operand helper function)</strong></em> 组成. 译码操作数辅助函数统一通过宏 <em><strong>def_DopHelper</strong></em> 来定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> def_DopHelper(name) \</span></span><br><span class="line"><span class="meta">  void concat(decode_op_, name) (Decode *s, Operand *op, word_t val, bool flag)</span></span><br></pre></td></tr></table></figure><p><em><strong>DopHelper</strong></em> 带有一个flag参数, 不同的 <em><strong>DopHelper</strong></em> 可以用它来进行不同的处理. 例如寄存器的 <em><strong>DopHelper</strong></em> 可以通过flag来指示是否写入:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="title function_">def_DopHelper</span><span class="params">(r)</span> &#123;</span><br><span class="line">  <span class="type">bool</span> is_write = flag;</span><br><span class="line">  <span class="type">static</span> <span class="type">word_t</span> zero_null = <span class="number">0</span>;</span><br><span class="line">  op-&gt;preg = (is_write &amp;&amp; val == <span class="number">0</span>) ? &amp;zero_null : &amp;gpr(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <em><strong>mips</strong></em> 和 <em><strong>riscv</strong></em> 中, 0号寄存器的值恒为0, 因此往0号寄存器的写入操作都会被硬件忽略. 为了实现这个功能, 上述代码会在译码的时候检查指令是否尝试往0号寄存器进行写入, 若是, 则把写入的目的修改成一个 <em><strong>“黑洞变量”</strong></em> , 这个变量不会被其它代码读取, 从而实现”往0号寄存器的写入操作都会被硬件忽略”的效果。</p><p>有了这些 <em><strong>译码操作数辅助函数（def_DopHelper）</strong></em> , 我们就可以用它们来编写 <em><strong>译码辅助函数（def_DHelper）</strong></em> 了, 例如 <em><strong>riscv</strong></em> 中 <em><strong>I-型指令</strong></em> 的译码过程可以通过如下代码实现:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="title function_">def_DHelper</span><span class="params">(I)</span> &#123;</span><br><span class="line">  decode_op_r(s, id_src1, s-&gt;isa.instr.i.rs1, <span class="literal">false</span>);       <span class="comment">// def_DopHelper(r)</span></span><br><span class="line">  decode_op_i(s, id_src2, s-&gt;isa.instr.i.simm11_0, <span class="literal">false</span>);  <span class="comment">// def_DopHelper(i)</span></span><br><span class="line">  decode_op_r(s, id_dest, s-&gt;isa.instr.i.rd, <span class="literal">true</span>);         <span class="comment">// def_DopHelper(r)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回到 <em><strong>def_INSTR_IDTAB</strong></em> 的宏展开结果, 对于 <em><strong>lui指令</strong></em>, 在 <em><strong>译码辅助函数decode_U()</strong></em> 执行结束后, 代码将会执行 <em><strong>table_lui()</strong></em> 。<em><strong>table_lui()</strong></em> 的定义方式比较特殊, 我们在这里先给出部分宏展开后的定义:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def_THelper(lui) &#123;</span><br><span class="line">  <span class="keyword">return</span> EXEC_ID_lui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>宏 <em><strong>def_THelper(在nemu&#x2F;include&#x2F;cpu&#x2F;decode.h中定义)</strong></em> 用于统一定义 <em><strong>“表格辅助函数”(table helper function)</strong></em> 。 <em><strong>table_lui()</strong></em> 做的事情很简单, 它直接返回一个标识lui指令的唯一ID. 这个ID会作为译码结果的返回值, 在 <em><strong>fetch_decode()</strong></em> 中索引 <em><strong>g_exec_table数组</strong></em> 。</p><p><em><strong>g_exec_table数组</strong></em> 其实就是一个存放指令执行函数指针的数组，通过正确的ID能映射到正确的指令执行函数，并将其赋值给 <em><strong>s</strong></em> 指向的 <em><strong>Decode</strong></em> 结构体。</p><p><em><strong>事实上, NEMU把译码时的如下情况都看作是查表过程：</strong></em></p><ul><li>在 <em><strong>isa_fetch_decode()</strong></em> 中查 <em><strong>主表(main decode table)</strong></em> ，其实就是 <em><strong>int idx &#x3D; table_main(s);</strong></em> 这句代码</li><li>在译码过程中分别匹配指令中的每一个域</li><li>译码出最终的指令时认为是一种特殊的查表操作, 直接返回标识该指令的唯一ID</li><li>如果所有模式匹配规则都无法成功匹配, 代码将会返回一个标识非法指令的ID</li></ul><p><em><strong>踩坑点以及感悟！！！！：</strong></em></p><ul><li>忽视了指令中 <em><strong>funct3</strong></em> 以及 <em><strong>funct7</strong></em> 的重要性，由于 <em><strong>RISCV-32</strong></em> 指令的高度统一性，如果你没有把手册中的所有有效信息在模式匹配的时候完全匹配上，就有可能会出现 <em><strong>指鹿为马</strong></em> 的坑爹情况。例如 <em><strong>ori</strong></em> 和 <em><strong>andi</strong></em> 这两个指令，他们的 <em><strong>opcode</strong></em> 完全一样，唯一的差别是前者的 <em><strong>funct3</strong></em> 为 <em><strong>110</strong></em>，而后者的为 <em><strong>111</strong></em>，仅一位之差，就有可能是完全不同的语义，请务必特别小心！</li><li>辅助函数太多，宏转发看的头晕，呆坐半天都无法理解是如何完成一条指令的译码的。原讲义中关于各种辅助函数的宏命名实在太过相像且没有突出显示，所以在我的笔记中我着重突出了辅助函数的名字，方便各位查阅。关于宏转发看的头晕的问题，最好的解决办法是画一张连线图，毕竟人脑无法模拟太复杂的状态机，把转发的过程画下来将更有助于你理解这整个过程。</li><li>这里我画了一张 <em><strong>lui指令</strong></em> 的译码流程图，供大家参考：<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/%E8%AF%91%E7%A0%81%E8%BF%87%E7%A8%8B%E5%9B%BE.png"></li><li>经过这些转发我们得到了什么？答案是我们得到了该指令所需要的 <em><strong>目的操作数和两个源操作数(部分是只有一个源操作数)<em><strong>，并将信息存储在了 <em><strong>s</strong></em> 所指向的 <em><strong>Decode</strong></em> 结构体中，以及返回了 <em><strong>指令的唯一ID</strong></em>，</strong></em>指令的唯一ID</strong></em> 将为我们索引 <em><strong>g_exec_table数组</strong></em> 并得到该指令唯一对应的指令执行函数，在这为我们后续执行指令的操作提供了必要的原材料。</li></ul>]]></content>
      
      
      <categories>
          
          <category> PA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C和C++中的inline</title>
      <link href="/archives/6aa13749.html"/>
      <url>/archives/6aa13749.html</url>
      
        <content type="html"><![CDATA[<p>inline是C和C++中都有的关键字，虽然名字一样，但在一些细节上还是有些许不同的。虽然网络上关于inline的讨论可谓是络绎不绝，但其中某些错误认知可谓是深入人心（bushi）。因此，本文尝试对其中的主要观点进行说明和验证。</p><h2 id="0x1-C和C-中的inline一样吗"><a href="#0x1-C和C-中的inline一样吗" class="headerlink" title="0x1. C和C++中的inline一样吗?"></a>0x1. C和C++中的inline一样吗?</h2><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>答案是不完全一样。</p><p>C语言中inline函数一般都是定义在头文件中，但请注意，此定义只是提供了一个内联版本，因此，该定义也被称为 <em><strong>内联定义</strong></em> 。C编译器并不会自动为我们提供非内联版本，需要我们在某一个.c文件中提供常规的非 <strong>inline</strong> 非 <strong>static</strong> 函数，或是声明为 <strong>extern inline</strong> 的函数，则此定义也被称作 <em><strong>外部定义</strong></em> 。如果不提供，则会在链接阶段发生报错，因为 <em><strong>内联定义</strong></em> 不会被放入符号表中，在链接时无法找到已经编译好的test函数，所以发生了链接错误。</p><p>此行为已经在C99标准规定了：</p><blockquote><p>引用自<a href="https://zh.cppreference.com/w/c/language/inline"><em><strong>cppreference.com</strong></em></a><br><em><strong>——为避免未定义行为，若在表达式中使用拥有外部链接的函数名，则程序中必须存在一个外部定义，见一个定义规则。</strong></em> </p></blockquote><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子 1"></a>例子 1</h3><p>这里我们给出例子，我使用的是 <strong>Debian</strong> 下的 <strong>gcc 10.2.1</strong>，优化等级限定在 <strong>O0</strong>。</p><p>test.h:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TEST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TEST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;test!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>main.c:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[], <span class="type">const</span> <span class="type">char</span> *envp[])</span> </span><br><span class="line">&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行编译，得到了一个链接错误，提示 <strong>‘test’</strong> 符号没有找到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">anya@debian:~/OSwork/test-code$ gcc --version</span><br><span class="line">gcc (Debian 10.2.1-6) 10.2.1 20210110</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line"></span><br><span class="line">anya@debian:~/OSwork/test-code$ gcc main.c -o main &amp;&amp; ./main</span><br><span class="line">/usr/bin/ld: /tmp/cc3k3H5m.o: in function `main&#x27;:</span><br><span class="line">main.c:(.text+0x19): undefined reference to `test&#x27;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure><p>为了解决这个问题也很简单，在 main.c 中加上外部定义即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[], <span class="type">const</span> <span class="type">char</span> *envp[])</span> </span><br><span class="line">&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">anya@debian:~/OSwork/test-code$ gcc main.c -o main &amp;&amp; ./main</span><br><span class="line">test!</span><br></pre></td></tr></table></figure><h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子 2"></a>例子 2</h3><p><em><strong>而对于C++来说，同一份包含 inline 函数的代码，即使不加外部定义，只需要把后缀从.c改成.cpp，就可以解决链接问题。</strong></em> </p><p>这里我们只是简单地修改了文件后缀名，使用同样的编译器和优化等级。</p><p>test.h:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TEST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TEST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;test!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>main.cpp:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[], <span class="type">const</span> <span class="type">char</span> *envp[])</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">anya@debian:~/OSwork/test-code$ g++ main.cpp -o main &amp;&amp; ./main</span><br><span class="line">test!</span><br></pre></td></tr></table></figure><p>到这里，其实我们就已经完成了证明，C++和C中的inline确实是不一样的，<em><strong>讨论   inline 关键字时，应该区分C语言和C++分别讨论。</strong></em></p><p>至于为什么改成.cpp后就消除了链接错误，如果要展开来说又是一番长篇大论。</p><p>简单来说，就是inline定义会在所有用到该函数但没有内联的.cpp中隐式实例化非内联版本。</p><p>如果你想要十分确切的理论依据，可以参考标准的解释：</p><blockquote><p>引用自<a href="https://zh.cppreference.com/w/cpp/language/inline"><em><strong>cppreference.com</strong></em></a><br><em><strong>——函数与变量 (C++17 起)的 inline 说明符</strong></em></p></blockquote><h2 id="0x2-inline在现代编译器里相当于弱符号指示符吗"><a href="#0x2-inline在现代编译器里相当于弱符号指示符吗" class="headerlink" title="0x2. inline在现代编译器里相当于弱符号指示符吗?"></a>0x2. inline在现代编译器里相当于弱符号指示符吗?</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>在编译时，编译器向汇编器输出每个全局符号，或者是 <em><strong>强（strong）</strong></em>或者是 <em><strong>弱（weak）</strong></em>，而汇编器把这个信息隐含地编码在可重定位目标文件的符号表里。<br>根据强弱符号的定义，Linux链接器使用下面的规则来处理多重定义的符号名。</p><ul><li>规则1：不允许有多个同名的强符号。</li><li>规则2：如果有一个强符号和多个弱符号同名，那么选择强符号。</li><li>规则3：如果有多个弱符号同名，那么从这些弱符号中任意选择一个。</li></ul><h3 id="正文-1"><a href="#正文-1" class="headerlink" title="正文"></a>正文</h3><p>当多个翻译单元（.cpp）都出现了同名内联函数（这里为了简单，排除了重载和模板的情况）的定义时，我们的链接器会如何选择呢？inline会让这些同名函数成为弱符号吗？<em><strong>答案是不同编译器的行为不一样，Linux gcc下确实是弱符号，而 Windows msvc却是强符号</strong></em>。所以inline是弱符号指示符是不完全正确的。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>首先考虑Linux gcc下的情况：</p><p>test.h:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TEST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TEST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;test!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>main.cpp:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[], <span class="type">const</span> <span class="type">char</span> *envp[])</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译和符号表结果如下，<em><strong>W</strong></em>表示全局弱符号，说明inline修饰起到了弱符号指示符的作用：</p><p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/nm.png"></p><p>同样的代码我们不加更改，在 Windows 下我们使用 vs2019 自带的 msvc 编译器，同样是编译后查看符号，发现 test 内联函数对应的符号并不是弱符号 <em><strong>W</strong></em> ，而是全局符号 <em><strong>T</strong></em>：</p><p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/msvc-nm.png"></p><h2 id="0x3-TODO"><a href="#0x3-TODO" class="headerlink" title="0x3. TODO"></a>0x3. TODO</h2>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C和C++中的inline </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令</title>
      <link href="/archives/caff8000.html"/>
      <url>/archives/caff8000.html</url>
      
        <content type="html"><![CDATA[<h2 id="初始化本地仓库"><a href="#初始化本地仓库" class="headerlink" title="初始化本地仓库"></a>初始化本地仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; git init</span><br></pre></td></tr></table></figure><h2 id="确认工作树和索引的状态"><a href="#确认工作树和索引的状态" class="headerlink" title="确认工作树和索引的状态"></a>确认工作树和索引的状态</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; git status</span><br></pre></td></tr></table></figure><h2 id="将文件添加到暂存区"><a href="#将文件添加到暂存区" class="headerlink" title="将文件添加到暂存区"></a>将文件添加到暂存区</h2><p>在 [file] 指定加入暂存区的文件, 用空格分隔多个文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; git add [file]..</span><br><span class="line"><span class="comment">## e.g.</span></span><br><span class="line">&gt;&gt; git add README.md</span><br><span class="line">&gt;&gt; git add README.md main.cpp</span><br></pre></td></tr></table></figure><h2 id="将所有新文件、更改过的文件添加到暂存区"><a href="#将所有新文件、更改过的文件添加到暂存区" class="headerlink" title="将所有新文件、更改过的文件添加到暂存区"></a>将所有新文件、更改过的文件添加到暂存区</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; git add .</span><br></pre></td></tr></table></figure><h2 id="提交更改-将暂存区内容添加到本地仓库中"><a href="#提交更改-将暂存区内容添加到本地仓库中" class="headerlink" title="提交更改, 将暂存区内容添加到本地仓库中"></a>提交更改, 将暂存区内容添加到本地仓库中</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; git commit -m <span class="string">&quot;first commit&quot;</span></span><br></pre></td></tr></table></figure><h2 id="查看更改日志"><a href="#查看更改日志" class="headerlink" title="查看更改日志"></a>查看更改日志</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><h2 id="添加一个远程存储库"><a href="#添加一个远程存储库" class="headerlink" title="添加一个远程存储库"></a>添加一个远程存储库</h2><p>请使用remote指令添加远程数据库。在 [name] 处输入远程数据库名称，在 [url] 处指定远程数据库的URL。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; git remote add [name] [url]</span><br><span class="line"><span class="comment">## e.g.</span></span><br><span class="line">&gt;&gt; git remote add origin https://[space_id].backlogtool.com/git/[project_key]/tutorial.git</span><br></pre></td></tr></table></figure><blockquote><p><em><strong>tips:</strong></em> 执行推送或者拉取的时候，如果省略了远程数据库的名称，则默认使用名为”origin“的远程数据库。因此一般都会把远程数据库命名为origin。</p></blockquote><h2 id="将分支推送到你的远程存储库"><a href="#将分支推送到你的远程存储库" class="headerlink" title="将分支推送到你的远程存储库"></a>将分支推送到你的远程存储库</h2><p>[remote-name&#x3D;origin] 处输入目标地址，[branch-name] 处指定推送的分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; git push [remote-name=origin] [branch-name]</span><br><span class="line"><span class="comment">## e.g.</span></span><br><span class="line">&gt;&gt; git push -u origin master</span><br></pre></td></tr></table></figure><blockquote><p><em><strong>tips:</strong></em> 运行以下命令便可向远程数据库‘origin’进行推送。当执行命令时，如果您指定了-u选项，那么下一次推送时就可以省略分支名称了。但是，首次运行指令向空的远程数据库推送时，必须指定远程数据库名称和分支名称。</p></blockquote><h2 id="拷贝Git仓库到本地"><a href="#拷贝Git仓库到本地" class="headerlink" title="拷贝Git仓库到本地"></a>拷贝Git仓库到本地</h2><p>在 [repository] 指定远程数据库的URL，在 [directory] 指定新目录的名称。[directory] 可省略不写，则默认 clone 到当前目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; git <span class="built_in">clone</span> [repository] [directory]</span><br><span class="line"><span class="comment">## e.g.</span></span><br><span class="line">&gt;&gt; git <span class="built_in">clone</span> https://github.com/Anyacoding/AnyaSTL.git myblog</span><br></pre></td></tr></table></figure><h2 id="从远程存储库中拉取更改"><a href="#从远程存储库中拉取更改" class="headerlink" title="从远程存储库中拉取更改"></a>从远程存储库中拉取更改</h2><p>使用pull指令进行拉取操作。省略数据库名称的话，会在名为origin的数据库进行pull。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; git pull [repository] [branch-name]</span><br><span class="line"><span class="comment">## e.g.</span></span><br><span class="line">&gt;&gt; git pull origin master</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git常用命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="/archives/bb0c7ac5.html"/>
      <url>/archives/bb0c7ac5.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>想起很久之前曾在Leetcode刷到过一道很经典的归并排序的题目，虽然题目不难，但实现起来并没有想象中那么容易。为了方便日后查阅，在这里特地记录一下</p><h2 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p><p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p><ul><li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</li><li>自下而上的迭代；</li></ul><p>为了代码的简洁，我这里采用的是递归的写法。</p><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><blockquote><p><em><strong>首先感谢<a href="https://www.cnblogs.com/chengxiao/p/6194356.html">图解排序算法(四)之归并排序</a>这篇文章的作者，对于归并排序的流程他完成了几幅很精美简洁的流程图，在这里分享给大家</strong></em></p></blockquote><p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/202207042134907.png"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r, vector&lt;<span class="type">int</span>&gt;&amp; temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l + <span class="number">1</span> &gt;= r) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// divide</span></span><br><span class="line">    <span class="type">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(nums, l, m, temp);</span><br><span class="line">    <span class="built_in">merge_sort</span>(nums, m, r, temp);</span><br><span class="line">    <span class="comment">// conquer</span></span><br><span class="line">    <span class="type">int</span> p = l, q = m, i = l;</span><br><span class="line">    <span class="keyword">while</span> (p &lt; m || q &lt; r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q &gt;= r || (p &lt; m &amp;&amp; nums[p] &lt;= nums[q])) &#123;</span><br><span class="line">            temp[i++] = nums[p++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[i++] = nums[q++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = l; i &lt; r; ++i) &#123;</span><br><span class="line">        nums[i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实战指路"><a href="#实战指路" class="headerlink" title="实战指路"></a>实战指路</h2><blockquote><p><a href="https://leetcode-cn.com/problems/sort-list/"><em><strong>Leetcode 148. Sort List (Medium)</strong></em></a></p></blockquote><p>“<em><strong>学会一种算法的最好方法就是去使用它。</strong></em>“<br><em><strong>Get your hand dirty！</strong></em></p><p>这里给出我的实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> ListNode* List;</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergesort</span>(head);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">List <span class="title">mergesort</span><span class="params">(List head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果第一或第二个结点是空结点，则不用归并，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        List fast, slow, fasttp, l, r;<span class="comment">//设定快慢指针来找中间结点；</span></span><br><span class="line">        fast = slow = head;</span><br><span class="line">        fasttp = head-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (fasttp != <span class="literal">NULL</span> &amp;&amp; fasttp-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fasttp = fasttp-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时slow-&gt;next即为中间结点</span></span><br><span class="line">        <span class="comment">//对右边进行归并</span></span><br><span class="line">        r = <span class="built_in">mergesort</span>(slow-&gt;next);</span><br><span class="line">        <span class="comment">//一个链表结束的标志是nullptr，所以这里进行cut操作，否则会出现一个循环的死</span></span><br><span class="line">        slow-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        l = <span class="built_in">mergesort</span>(head);</span><br><span class="line">        <span class="comment">//最后将左右两段进行一个合并</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(l, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">List <span class="title">merge</span><span class="params">(List l, List r)</span> </span>&#123;</span><br><span class="line">        List temphead = <span class="keyword">new</span> ListNode;</span><br><span class="line">        List p = temphead;</span><br><span class="line">        <span class="keyword">while</span> (l &amp;&amp; r) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l-&gt;val &lt;= r-&gt;val) &#123;</span><br><span class="line">                p-&gt;next = l;</span><br><span class="line">                l = l-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p-&gt;next = r;</span><br><span class="line">                r = r-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当左边有剩余时</span></span><br><span class="line">        <span class="keyword">if</span> (l != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            p-&gt;next = l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当右边有剩余时</span></span><br><span class="line">        <span class="keyword">if</span> (r != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            p-&gt;next = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temphead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++内存对齐问题</title>
      <link href="/archives/af823184.html"/>
      <url>/archives/af823184.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天热心(huaidan)群友在群里出了这样一个问题: <mark class="hl-label pink">请推测出下列代码的输出，在32位系统下.</mark> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> a = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    <span class="built_in">myclass</span>(): arr&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, <span class="built_in">p</span>(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">2</span>]) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">myclass</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    myclass obj; </span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(obj.arr) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(obj.p) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(obj);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我的答案是12 4 25，嘿嘿，我还信心满满的捏。因为我已经注意到了要把虚函数表隐含的那根指针算进去。然而我还是被坑了。</p><mark class="hl-label pink">正确答案如下:</mark> <p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/202207042134912.png"><br>前两个没什么好说的，主要是第三个输出。28是这么来的：<em><strong>28 &#x3D; vptr4 + f4 + c4 + arr12 + p4</strong></em></p><p>如果你没有接下来将要介绍的知识，估计你也会疑惑，为什么char的大小不是1字节而是4字节呢？如果char在这里的大小为1字节，结果将是我所预测的25。</p><p>然而事实却是，一个结构体或类定义完后，其在内存中的存储并不等于其所包含的元素的宽度之和。<br>这就是<em><strong>内存对齐问题</strong></em></p><p>首先感谢<a href="https://blog.csdn.net/liukun321/article/details/6974282">结构体在内存中的对齐规则 - 咕唧咕唧shubo.lk的专栏 - 博客频道 - CSDN.NET</a>这篇文章的作者，正是通过他的博客，我才真正弄懂了内存对齐问题</p><h2 id="原则一"><a href="#原则一" class="headerlink" title="原则一"></a>原则一</h2><p><em><strong>结构体中元素是按照定义顺序一个一个放到内存中去的，但并不是紧密排列的。从结构体存储的首地址开始，每一个元素放置到内存中时，它都会认为内存是以它自己的大小来划分的，因此元素放置的位置一定会在自己宽度的整数倍上开始（以结构体变量首地址为0计算）。</strong></em></p><p>比如我们上面举的例子，首先系统会将虚函数表指针放入第0-3个字节(这里指的时相对地址，即内存开辟的首地址)，这里是另外一个知识了，<em><strong>若一个类中有虚函数，那么他的虚函数表指针将放在类的开头</strong></em>；然后在存放float型变量时，会以4个字节为单位进行存储，也就是在第4-7个字节；然后是放入char型变量，每个char以1个字节为单位进行存储，也就是放在第8个字节；然后是放入int型数组，这个数组有3个元素，也就是将要放入3个int，每个int以4个字节为单位进行存储，由于前三个四字节模块已经有数据，所以这个数组会被存放在第12-23个字节；最后是指针p，在32位系统下指针的宽度为4个字节，所以他会被放在第24-27个字节。</p><mark class="hl-label pink">整体存储示意图如下所示:</mark> <p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/202207042134914.png"><br>到这里还没完，让我们试着把float改成double试试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> a = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    <span class="built_in">myclass</span>(): arr&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, <span class="built_in">p</span>(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">2</span>]) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">myclass</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    myclass obj; </span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(obj.arr) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(obj.p) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(obj);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了上面介绍的原则一，我们不难算出obj的大小为 <em><strong>36 &#x3D; 8 + 8 + 4 + 12 + 4</strong></em>，和上面计算过程中唯一的区别是我们的虚函数表指针由于double的对齐问题，被看作了一个8字节大小的单元。</p><p>然而事实却不是这样。<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/202207042134913.png"><br>而这就引出了我们的第二原则。</p><h2 id="原则二"><a href="#原则二" class="headerlink" title="原则二"></a>原则二</h2><p><em><strong>在经过第一原则分析后，检查计算出的存储单元是否为所有元素中最宽的元素的长度的整数倍，是，则结束；若不是，则补齐为它的整数倍。</strong></em></p><p>在上面这个例子中，我们分析完后的存储长度为36字节，不是最宽元素double长度的整数倍，因此将36补齐到8的整数倍，也就是40。这样就没问题了。</p><mark class="hl-label pink">其存储示意图如下所示:</mark> <p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/202207042134915.png"><br>掌握了这两个原则，就足以分析所有数据存储的对齐问题了。快去找几个例子试试吧！</p><hr><p>这里进行一个补充：由于static成员并不属于类的实例对象，所以在计算的时候请注意不要把static成员考虑进来捏~</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++内存对齐问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于C语言scanf函数吃人事件</title>
      <link href="/archives/66d72fbf.html"/>
      <url>/archives/66d72fbf.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大一的时候刚刚接触c语言，使用scanf函数总是会莫名出现各种奇怪的输入问题，想想还真是踩了很多坑捏呜呜。例如输入数据时，会发现若%d后面加了空格之后按下回车键控制台没有响应，这其实就是吃空白行为。</p><p>给变量赋值实际上需要从缓冲区提取合适的数据到变量中，而缓冲区的数据其实是由我们的键盘来输入的。</p><mark class="hl-label pink">举个例子:</mark> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;x = %d\ny = %d&quot;</span>, x, y);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面这段代码，我们可以有两种输入方法。一种是输入x的值，然后空格，然后输入y的值</p><p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/KMI5DOV4BC08U4XH.png"></p><p>另一种是输入x的值，回车，然后输入y的值</p><p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/T_6PKH61Z9A@FP7SYO5RO.png"></p><p>不难发现，其实两种输入方式的回车和空格都没有被输入到y中，这是我们所期望的。这是因为%d的匹配机制，会不断丢弃空白符(<mark class="hl-label pink">包括回车，空白等</mark> )，直到出现数字字符，然后scanf开始解析数字字符串，再将解析好的数值存入到y中。至此一个%d的匹配工作完成，当然，最后结束输入的时候我们还按了一个回车，这个回车仍然留在缓冲区中没被处理。</p><p>通过上述的实验我们可以知道，%d会自动把缓冲区中数字字符串之前的空白符全部扔掉，也就是恰空白行为。</p><h2 id="关于-d无响应问题"><a href="#关于-d无响应问题" class="headerlink" title="关于%d无响应问题"></a>关于%d无响应问题</h2><p>由于作为一名c语言弱鸡，对于格式化的要求往往非常随意，我在使用%d时常常最后面错误地多加了一个空格，从而导致了输入无法正常结束。也就会发生经典剧情，“<mark class="hl-label pink">明明我们的代码一模一样，为什么我的就运行不了呜呜。</mark> ” 我们需要知道，当%d的匹配工作完成后，%d后面的空格开始工作，空格意味着丢掉所有空白符，因此无论我们输入多少个空格和回车，scanf都不会正常结束。要使scanf函数结束，我们需要输入一个非空白字符，来使得空格吃空白符的工作结束。</p><p>细心的同学应该发现了，其实我们最后输入的那个非空白符任然留在缓冲区中，没有被处理，在下次输入时就会被事与愿违地读取，我们来看这一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d &quot;</span>, &amp;x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x = %d\n&quot;</span>, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/628H_N7IKDHWOT8T.png"></p><p>不建议在%d后面加入空格捏</p><h2 id="吃空白的其他烹饪方式"><a href="#吃空白的其他烹饪方式" class="headerlink" title="吃空白的其他烹饪方式"></a>吃空白的其他烹饪方式</h2><p>由于%d本身就会吃掉整形数前面的所有空白符，所以在%d前面加不加空格都无所谓捏。但是对于字符%c来说情况就完全不同了，由于空白符本身也是一种字符，所以%c会错误地把多余地空格以及回车等东东读入捏。</p><p>我们看下面的一组例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span> y = <span class="string">&#x27;&#x27;;</span></span><br><span class="line"><span class="string">  scanf(&quot;%d&quot;, &amp;x);</span></span><br><span class="line"><span class="string">  scanf(&quot;%c&quot;, &amp;y);</span></span><br><span class="line"><span class="string">  printf(&quot;x = %d\ny = %c&quot;, x, y);</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/8NML31TBKRS@ILNK1M2X.png"></p><p>可以明显看到，留在缓冲区中的空格被y读取了。你可以去试试，输入x的值，回车，再输入y的值，缓冲区中的回车同样会被y读取。</p><p>为了达到我们想要的效果，我们可以在%c前面加一个空格，来把缓冲区中多余的空白符吃掉：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span> y = <span class="string">&#x27;&#x27;;</span></span><br><span class="line"><span class="string">  scanf(&quot;%d&quot;, &amp;x);</span></span><br><span class="line"><span class="string">  scanf(&quot; %c&quot;, &amp;y);</span></span><br><span class="line"><span class="string">  printf(&quot;x = %d\ny = %c&quot;, x, y);</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/PDF0ELCJ7H08KQTBO7A.png"></p><p>我们得到了我们想要的效果。</p><p>因此，当我们的输入中不想错误地读取空白字符时，建议你在%c前面加上一个空格。</p><p>对于%s的处理方式，和%c非常相似。%s遇到空白符就会认为这个字符串输入完毕了，且这个空白符及其之后的输入仍然会留在缓冲区中。</p><p>上例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入一串字符：&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;这个字符串为:%s\n&quot;</span>, str);</span><br><span class="line">  gets(str);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;这个字符串为:%s\n&quot;</span>, str);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/WIYCBKZND7_P1HRX.png"><br>这里我用gets函数把留在缓冲区中的内容全都取了出来，结果很显然了</p><p>对于scanf吃空白这一技巧，其实更多的是一种技术细节，比起死记硬背他的用法，更重要的是我们应该理解这背后的原理，这样方能以不变应万变</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
