<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机图形学一：矩阵变换</title>
      <link href="/archives/20c47d09.html"/>
      <url>/archives/20c47d09.html</url>
      
        <content type="html"><![CDATA[<p>本系列文章是按照 <a href="https://www.bilibili.com/video/BV1X7411F744/?spm_id_from=333.337.search-card.all.click&amp;vd_source=2652d832108fec04c7b16fcf850e5ca7"><strong><em>games101</em></strong></a> 上课讲授的内容编写的，相当于课后笔记，方便查漏补缺，<del>也方便实现代码时好抄公式</del> 。</p><hr><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>在图形学中，线性代数的重要性实在是太重要了。线性代数为图形学提供了一种十分优雅且便捷的数学工具——变换矩阵（<strong><em>Transformation Marices</em></strong>），来描述空间中物体的旋转，缩放和平移，并且在各种投影变换下也有许多应用。要理解图形学，从几何的角度来理解线性代数是十分必要的。</p><h2 id="2D线性变换"><a href="#2D线性变换" class="headerlink" title="2D线性变换"></a>2D线性变换</h2><p>我们可以将简单的矩阵乘法定义为对列向量 $(x,y)^T$ 的线性变换：</p><script type="math/tex; mode=display">\begin{bmatrix}{a_{11}}&{a_{12}}\\{a_{21}}&{a_{22}}\\\end{bmatrix} \begin{bmatrix}x\\y\\\end{bmatrix} =\begin{bmatrix}{a_{11}}x + {a_{12}}y\\{a_{21}}x + {a_{22}}y\\\end{bmatrix}</script><h3 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h3><p>缩放变换是一种沿着坐标轴作用的变换，形式如下：</p><script type="math/tex; mode=display">M_{scale}(s_x, s_y)=\begin{bmatrix}s_x & 0\\0 & s_y\\\end{bmatrix}</script><p>为什么说这个矩阵能起到缩放的作用呢？这里提供一个思路。</p><p>众所周知，二维平面上的任意一点都能与原点相连形成一个向量 $(x,y)^T$ ，除此之外，我们还能用另外一种形式来表示这个向量 $x\hat i + y\hat j$ ，其中 $\hat i$ 和 $\hat j$ 分别代表了 $x$ 轴和 $y$ 的单位正向量，即 <strong><em>二维平面上的任意一个向量都能由两个单位基向量的线性组合来表示</em></strong>。</p><p>那么当向量 $(x,y)^T$ 左乘上这个缩放矩阵时会得到下面的形式：</p><script type="math/tex; mode=display">\begin{bmatrix}s_x & 0\\0 & s_y\\\end{bmatrix} \begin{bmatrix}x\\y\\\end{bmatrix} =x\begin{bmatrix}s_x\\0\\\end{bmatrix} +y\begin{bmatrix}0\\s_y\\\end{bmatrix} =\begin{bmatrix}s_x x\\s_y y\\\end{bmatrix}</script><p>相当于我们得到了一个 <script type="math/tex">x\begin{bmatrix}s_x\\ 0\\ \end{bmatrix}+ y\begin{bmatrix}0\\ s_y\\ \end{bmatrix}</script> 的向量，我们可以把该过程理解为用一组新的基向量来解释向量 $(x,y)^T$。<script type="math/tex">\begin{bmatrix}s_x\\ 0\\ \end{bmatrix}</script> 是 $\hat i$ 的 $s_x$ 倍，<script type="math/tex">\begin{bmatrix}0\\ s_y\\ \end{bmatrix}</script> 是 $\hat j$ 的 $s_y$ 倍，那么在标准坐标系下向量 $(x,y)^T$ 被重新解释为 $(s_x x,s_y y)^T$，横纵坐标分别被放缩为原来的 $s_x$ 倍 和 $s_y$ 倍。</p><p>最后再用两个简单的实际例子来展示一下缩放矩阵的作用：<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/v2-ae48c1455b68fc5593b8788287235309_720w.webp" alt=""><br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/v2-b1a9d665cece63d7e984936641b7ebab_720w.webp" alt=""></p><h3 id="剪切"><a href="#剪切" class="headerlink" title="剪切"></a>剪切</h3><p>剪切其实跟缩放很像，只不过剪切是把一边固定，然后拉向另一个方向，形式如下：</p><script type="math/tex; mode=display">M_{shear-X}(s)=\begin{bmatrix}1 & s\\0 & 1\\\end{bmatrix},\quadM_{shear-Y}(s)=\begin{bmatrix}1 & 0\\s & 1\\\end{bmatrix}</script><p>我们还是沿用上面的思路，以固定 $x$ 轴为例子，当向量 $(x,y)^T$ 左乘上这个矩阵时会得到：</p><script type="math/tex; mode=display">\begin{bmatrix}1 & s\\0 & 1\\\end{bmatrix}\begin{bmatrix}x\\y\\\end{bmatrix} =x\begin{bmatrix}1\\0\\\end{bmatrix} +y\begin{bmatrix}s\\1\\\end{bmatrix} =\begin{bmatrix}x + sy\\y\\\end{bmatrix}</script><p>新的 $x$ 轴的基向量仍然是 $\hat i$，这也是为什么我们说这是一个固定 $x$ 轴的变换；新的 $y$ 轴的基向量为 <script type="math/tex">\begin{bmatrix}s\\ 1\\ \end{bmatrix}</script>，相当于 $\hat j$ 保持高度不变，然后向原来的 $x$ 轴正方向拉伸了 $s$ 个单位距离。</p><p>从几何上来直观观察就是物体向某个方向倾倒了：<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/v2-f4aa66cbabade26576291e780feca4f9_720w.webp" alt=""><br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/v2-aa233efa70a9bae5152b33da75934f3c_720w.webp" alt=""></p><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>旋转在图形学中可谓是非常重要的一种变换矩阵了，如下我们考虑如何用一个变换矩阵将向量 $a$ 旋转到 $b$ 的位置：<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/v2-2fa721a848bea3d598ccf5c228228adb_720w.webp" alt="我们默认以原点为旋转中心，并逆时针旋转"><br>这里我们先给出答案：</p><script type="math/tex; mode=display">M_{rotate}(\phi)=\begin{bmatrix}cos\phi & -sin\phi\\sin\phi & cos\phi\\\end{bmatrix}</script><p>我们继续沿用上面的思路来证明这个矩阵的有效性。首先我们需要得到向量 $a$，假设向量 $a$ 的长度为 $r$，有一初始向量为 $(r, 0)^T$ 。</p><p>其实根据前面两个变换我们已经可以得出这样一个角度，一个变换矩阵其实描述了变换后，新的基向量的具体形式。我们可以想象把整个坐标轴逆时针旋转 $\alpha$，这样新的坐标轴就和向量 $a$ 重合了，那么 $(r, 0)^T$ 就可以被解释为向量 $a$ 了，其中新的 $x$ 轴基向量为 <script type="math/tex">\begin{bmatrix}cos\alpha\\ sin\alpha\\ \end{bmatrix}</script>，新的 $y$ 轴基向量为 <script type="math/tex">\begin{bmatrix}-sin\alpha\\ cos\alpha\\ \end{bmatrix}</script>，我们可以很容易地得到这样一个变换：</p><script type="math/tex; mode=display">\begin{bmatrix}cos\alpha & -sin\alpha\\sin\alpha & cos\alpha\\\end{bmatrix} \begin{bmatrix}r\\0\\\end{bmatrix} = r\begin{bmatrix}cos\alpha\\ sin\alpha\\ \end{bmatrix}+0\begin{bmatrix}-sin\alpha\\ cos\alpha\\ \end{bmatrix}=\begin{bmatrix}rcos\alpha\\rsin\alpha\\\end{bmatrix}</script><p>可以看到，这确实就是向量 $a$ 的坐标。那么得到向量 $b$ 我们也如法炮制，在向量 $a$ 的基础上再旋转 $\phi$：</p><script type="math/tex; mode=display">\begin{bmatrix}cos\phi & -sin\phi\\sin\phi & cos\phi\\\end{bmatrix} \begin{bmatrix}rcos\alpha\\rsin\alpha\\\end{bmatrix} = rcos\alpha\\begin{bmatrix}cos\phi\\ sin\phi\\ \end{bmatrix}+rsin\alpha\\begin{bmatrix}-sin\phi\\ cos\phi\\ \end{bmatrix}=\begin{bmatrix}r(cos\alpha cos\phi - sin\alpha sin\phi)\\r(cos\alpha sin\phi + sin\alpha cos\phi)\\\end{bmatrix}</script><script type="math/tex; mode=display">\Downarrow</script><script type="math/tex; mode=display">\begin{bmatrix}rcos(\alpha + \phi)\\rsin(\alpha + \phi)\\\end{bmatrix}</script><p>我们正确地得到了向量 $b$ 的坐标，到此为止，我们证明了旋转矩阵的正确性。</p><p>下面举一个逆时针旋转 $45^。$ 的例子：<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/v2-a46dafc052b4e363775e98dadf53a049_720w.webp" alt=""></p><h2 id="3D线性变换"><a href="#3D线性变换" class="headerlink" title="3D线性变换"></a>3D线性变换</h2><p>前面我们已经介绍了二维的线性变换，那么拓展到三维其实相对简单的，我们一起来看一下。</p><h3 id="缩放-1"><a href="#缩放-1" class="headerlink" title="缩放"></a>缩放</h3><p>我们只需要把 $z$ 轴也考虑进来就好：</p><script type="math/tex; mode=display">M_{scale}(s_x, s_y, s_z)=\begin{bmatrix}s_x & 0 & 0\\0 & s_y & 0\\0 & 0 & s_z\\\end{bmatrix}</script><h3 id="剪切-1"><a href="#剪切-1" class="headerlink" title="剪切"></a>剪切</h3><p>剪切也是类似的，我们仍然举固定 $x$ 轴的例子：</p><script type="math/tex; mode=display">M_{shear-X}(s_y, s_z)=\begin{bmatrix}1 & s_y & s_z\\0 & 1 & 0\\0 & 0 & 1\\\end{bmatrix}</script><h3 id="旋转-1"><a href="#旋转-1" class="headerlink" title="旋转"></a>旋转</h3><p>在旋转的时候三维和二维就有些不同了，在三维中我们可以绕 $x$ 轴，$y$ 轴，$z$ 轴旋转，因此一般来说有三类旋转矩阵。在讨论基础旋转时我们仍然是以逆时针旋转，并且以坐标轴为旋转轴。</p><p>此处我们采用的坐标系是右手坐标系，以屏幕建立该坐标系，右手为 $x$ 轴正方向，向上为 $y$ 轴正方向，屏幕从里朝外为 $z$ 轴正方向，坐标原点为屏幕正中心。</p><h4 id="绕z轴旋转"><a href="#绕z轴旋转" class="headerlink" title="绕z轴旋转"></a>绕z轴旋转</h4><p>让我们回想一下在二维坐标下的旋转，我们是以 $x$ 轴转向 $y$ 轴的（逆时针），根据右手螺旋定则，$x\rightarrow y$ 正好是 $z$ 轴正方向，$z$ 轴坐标不变，因此绕 $z$ 轴旋转很容易写出来：</p><script type="math/tex; mode=display">M_{rotate-Z}(\phi)=\begin{bmatrix}cos\phi & -sin\phi & 0\\sin\phi & cos\phi & 0\\0 & 0 & 1\\\end{bmatrix}</script><p>可以看到这跟二维的形式非常像，十分好记。</p><h4 id="绕x轴旋转"><a href="#绕x轴旋转" class="headerlink" title="绕x轴旋转"></a>绕x轴旋转</h4><p>我们以 $y$ 轴转向 $z$ 轴的（逆时针），根据右手螺旋定则，$y\rightarrow z$ 正好是 $x$ 轴正方向，$x$ 轴坐标不变：</p><script type="math/tex; mode=display">M_{rotate-X}(\phi)=\begin{bmatrix}1 & 0 & 0\\0 &cos\phi & -sin\phi\\0 & sin\phi & cos\phi\\\end{bmatrix}</script><h4 id="绕y轴旋转"><a href="#绕y轴旋转" class="headerlink" title="绕y轴旋转"></a>绕y轴旋转</h4><p>我们以 $z$ 轴转向 $x$ 轴的（逆时针），根据右手螺旋定则，$z\rightarrow x$ 正好是 $y$ 轴正方向，$y$ 轴坐标不变：</p><script type="math/tex; mode=display">M_{rotate-X}(\phi)=\begin{bmatrix}cos\phi & 0 & sin\phi\\0 &1 & 0\\-sin\phi & 0 & cos\phi\\\end{bmatrix}</script><p>注意，我们绕 $y$ 轴旋转的时候右上角和左下角的符号调换了，为什么会这样呢？这跟顺逆时针没关系，主要是因为我们描述坐标时是以 $(x,y,z)$ 的顺序来描述的，我们的矩阵的列向量也是以这个顺序。此时 $z$ 轴相当于横坐标，$x$ 轴相当于纵坐标，类比二维旋转我们就可以知道了，为纵坐标的那一个轴第二项为负数，因此我们得到了这一个看起来不太一样的形式。</p><h4 id="正交"><a href="#正交" class="headerlink" title="正交"></a>正交</h4><p>我们还需要注意到一个事实，即所有的旋转矩阵全都是正交矩阵，那么旋转矩阵的逆就是它的转置，根据这个特性，我们能够很容易地实现逆时针旋转和顺时针旋转。</p><h2 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h2><p>严格来说，平移并非是线性变换，但他又确实是图形学中一种十分常用的变换。如果我们仍然使用当前体系下的表示形式，是不能用一个矩阵同时表示平移和线性变换的，这实在太不方便了。为此我们将引入齐次坐标的概念，把线性变换和平移统一起来，统称为仿射变换。</p><h3 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h3><p>要表示平移其实非常简单：</p><script type="math/tex; mode=display">\begin{bmatrix}x_{shift}\\y_{shift}\\\end{bmatrix} =\begin{bmatrix}x\\y\\\end{bmatrix} +\begin{bmatrix}x_t\\y_t\\\end{bmatrix} =\begin{bmatrix}x+x_t\\y+y_t\\\end{bmatrix}</script><p>可以看到，但是从形式上来说就跟原来的体系不兼容了，想要表示一个物体先缩放后平移或许得这么表示：</p><script type="math/tex; mode=display">M_{scale}\begin{bmatrix}x\\y\\\end{bmatrix} +\begin{bmatrix}x_t\\y_t\\\end{bmatrix}</script><p>额…….有点小丑.</p><h3 id="齐次坐标系"><a href="#齐次坐标系" class="headerlink" title="齐次坐标系"></a>齐次坐标系</h3><p>我们引入一维新的坐标，称之为齐次坐标，$(x, y)^T \rightarrow    (x, y, 1)^T$。现在我们再看我们如何来表示一个物体先缩放后平移：</p><script type="math/tex; mode=display">M_{scale \rightarrow shift}\begin{bmatrix}x\\y\\1\\\end{bmatrix} =\begin{bmatrix}s_x & 0 & x_t\\0 & s_y & y_t\\0 & 0 & 1\\\end{bmatrix} \begin{bmatrix}x\\y\\1\\\end{bmatrix} =\begin{bmatrix}s_x x + x_t\\s_y y + y_t\\1\\\end{bmatrix}</script><p>太优雅了，不是吗？我们以多引入一维的代价得到了一个统一的形式来描述变换矩阵，真是可喜可贺。不过需要注意的是，让我们用齐次坐标系来表示物体的变换时，是先进行线性变换，再进行平移变换的，从上面的结果我们也可以看出这一点。</p><p>还有一点，我们一般用 $(x, y, w)^T$ 这样的形式来表示齐次坐标，其中 $w$ 为 <strong><em>0</em></strong> 时，代表这是一个向量，当 $w$ 非 <strong><em>0</em></strong> 时，代表这是一个点。为什么这么规定呢？我们知道，向量具有平移不变性，一个向量被平移过后还是原来的向量，如果 $w$ 为0，就可以保证这一点：</p><script type="math/tex; mode=display">\begin{bmatrix}1 & 0 & x_t\\0 & 1 & y_t\\0 & 0 & 1\\\end{bmatrix} \begin{bmatrix}x\\y\\0\\\end{bmatrix} =\begin{bmatrix}x\\y\\0\\\end{bmatrix}</script><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ol><li><a href="https://www.bilibili.com/video/BV1ys411472E/?spm_id_from=333.999.0.0"><strong><em>3Blue1Brown 线性代数的本质</em></strong></a> </li><li><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html"><strong><em>games101课程主页</em></strong></a>    </li><li><a href="https://www.bilibili.com/video/BV1X7411F744/?spm_id_from=333.337.search-card.all.click&amp;vd_source=2652d832108fec04c7b16fcf850e5ca7"><strong><em>games101课程观看地址</em></strong></a>    </li><li><a href="https://games-cn.org/forums/topic/allhw/"><strong><em>games101课程作业汇总</em></strong></a> </li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> games101 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速幂</title>
      <link href="/archives/1599bffe.html"/>
      <url>/archives/1599bffe.html</url>
      
        <content type="html"><![CDATA[<h2 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h2><p>快速幂，也成为二进制取幂（<strong><em>Binary Exponentiation</em></strong>），是一个在  $\omicron(\log n)$ 的时间内计算 $a^n$ 的小 <strong><em>trick</em></strong>，而暴力的方法需要 $\omicron(n)$ 的时间。</p><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>计算 $a$ 的 $n$ 次方表示将 $n$ 个 $a$ 乘在一起：$a^n=\underbrace{a \times a \cdots \times a}_n$ ，然而当 $n$ 很大时，这种方法就比较慢了。不过我们知道，根据幂的性质，$a^{b+c}=a^b \times a^c$ ，$a^{2b}=a^b \times a^b=(a^b)^2$ 。快速幂的想法就是，我们将取幂的任务按照指数的 <strong><em>二进制表示</em></strong> ，以此来分割成更小的任务。</p><h2 id="求解过程"><a href="#求解过程" class="headerlink" title="求解过程"></a>求解过程</h2><p>我们首先举一个 $a^n$ 的具体的例子，并将 $n$ 表示为二进制：</p><script type="math/tex; mode=display">7^{12}=7^{(1100)_2}=7^8 \times 7^4</script><p>因为 $n$ 可以由 $\lfloor log_2 n \rfloor + 1$ 个二进制位来表示，我们可以观察上面的例子，这 $\lfloor log_2 n \rfloor + 1$ 个二进制位中有的位是 <strong><em>1</em></strong> ，有的位是 <strong><em>0</em></strong>，我们只需要把对应二进制位为 <strong><em>1</em></strong> 的整系数幂乘起来就行了。我们现在假设第 $i$ 位上的数为 <strong><em>1</em></strong>，那么很容易就可以得出一般化的形式：</p><script type="math/tex; mode=display">a^n=\prod_{i=0}^{\lfloor log_2 n \rfloor}a^{2^i}</script><p>需要注意我们是从 <strong><em>0</em></strong> 开始计算位数的，这样幂的性质和二进制的表示能完美地配合起来。因为至多需要把 $\lfloor log_2 n \rfloor + 1$ 个整系数幂乘起来，因此这个算法的时间复杂度是 $\omicron(\log n)$。</p><p>还有一个尾巴需要解决，我们还需要在每一步中计算出 $a^{2^i}$，这个其实非常容易解决。在我们迭代的过程中可以动态维护 $a^{2^i}$ 这个变量，并在常数时间内从 $a^{2^i}$ 推出 $a^{2^{i+1}}$:</p><script type="math/tex; mode=display">a^{2^i} \times a^{2^i} = a^{2^{i+1}}</script><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>这里我们给出非递归的形式，根据上述推导得出的公式这并不难完成：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">quickPow</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">1</span>) ans *= a;</span><br><span class="line">    a *= a;</span><br><span class="line">    n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="实战指路"><a href="#实战指路" class="headerlink" title="实战指路"></a>实战指路</h2><p><a href="https://leetcode-cn.com/problems/sort-list/"><strong><em>Leetcode 50. Pow(x, n) (Medium)</em></strong></a></p><p>“<strong><em>Talk is cheap, show me the code!</em></strong>“<br>——<strong><em>Linus Benedict Torvalds</em></strong></p><p>这里给出我的实现代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        <span class="type">bool</span> negative = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            negative = <span class="literal">true</span>;</span><br><span class="line">            n = <span class="built_in">abs</span>(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n &amp; <span class="number">1</span>) res *= x;</span><br><span class="line">            x *= x;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> negative ? <span class="number">1</span> / res : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快速幂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SocketLab3：SMTP</title>
      <link href="/archives/4f4fa075.html"/>
      <url>/archives/4f4fa075.html</url>
      
        <content type="html"><![CDATA[<p><em><strong>官方英文资源网站</strong></em> ：<a href="https://media.pearsoncmg.com/ph/esm/ecs_kurose_compnetwork_8/cw/"><em><strong>Pearson Computer Networking: a Top-Down Approach, 8th Edition</strong></em></a></p><p><em><strong>直接下载</strong></em>：<a href="https://media.pearsoncmg.com/ph/esm/ecs_kurose_compnetwork_8/cw/content/python-socket-programming-assignments.zip"><em><strong>Python 3 Socket Programming Assignments</strong></em></a></p><p><em><strong>以下内容为笔者翻译</strong></em> ：</p><hr><p>通过完成本实验，你将更加理解 <em><strong>STMP</strong></em> 协议。与此同时，你将会得到使用 <em><strong>Python</strong></em> 实现一个标准协议的经验。</p><p>你的任务是开发一个简单的邮件客户端来发送邮件给任意收件人。你的客户端需要连接到一个邮件服务器，使用 <em><strong>STMP</strong></em> 协议与邮件服务器进行通信，并发送一封电子邮件到邮件服务器。<em><strong>Python</strong></em> 提供了一个叫做 <code>smtplib</code> 的模块，该模块内置了使用 <em><strong>STMP</strong></em> 协议来发送邮件的方法。然而，在本实验中我们不会使用这个模块，因为它把 <em><strong>STMP</strong></em> 协议和套接字编程的细节隐藏起来了。</p><p>为了拦截垃圾邮件，一些邮件服务器不接受来自任意未知源的 <em><strong>TCP</strong></em> 连接。对于下面所描述的实验，你可能想要尝试连接你本校的邮件服务器和一个流行的网页邮件服务器，例如一个 <em><strong>AOL</strong></em> 邮件服务器。你也可以尝试从你家到你本校校园进行连接。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>下面你会找到客户端的框架代码。你的任务是完成这个框架代码。你需要填写代码的地方已经被 <code>#Fill in start</code> 和 <code>#Fill in end</code> 标记出来了。每个地方可能需要一至多行代码。</p><h2 id="额外提示"><a href="#额外提示" class="headerlink" title="额外提示"></a>额外提示</h2><p>在某些情况下，接收邮件服务器可能会将你的邮件视为垃圾。当你需要查找从客户端发送的邮件时，确保你检查了垃圾邮件文件夹。</p><h2 id="要上交的内容"><a href="#要上交的内容" class="headerlink" title="要上交的内容"></a>要上交的内容</h2><p>在你的提交中，你需要提供完整的 <em><strong>STMP</strong></em> 邮件客户端代码，并且附带截图展示你确实收到了电子邮件。</p><h2 id="邮件客户端的Python代码框架"><a href="#邮件客户端的Python代码框架" class="headerlink" title="邮件客户端的Python代码框架"></a>邮件客户端的Python代码框架</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">msg = <span class="string">&quot;\r\n I love computer networks!&quot;</span></span><br><span class="line">endmsg = <span class="string">&quot;\r\n.\r\n&quot;</span></span><br><span class="line"><span class="comment"># Choose a mail server (e.g. Google mail server) and call it mailserver </span></span><br><span class="line">mailserver = <span class="comment">#Fill in start   #Fill in end</span></span><br><span class="line"><span class="comment"># Create socket called clientSocket and establish a TCP connection with mailserver</span></span><br><span class="line"><span class="comment">#Fill in start</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Fill in end</span></span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="built_in">print</span> recv</span><br><span class="line"><span class="keyword">if</span> recv[:<span class="number">3</span>] != <span class="string">&#x27;220&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;220 reply not received from server.&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Send HELO command and print server response.</span></span><br><span class="line">heloCommand = <span class="string">&#x27;HELO Alice\r\n&#x27;</span></span><br><span class="line">clientSocket.send(heloCommand)</span><br><span class="line">recv1 = clientSocket.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="built_in">print</span> recv1</span><br><span class="line"><span class="keyword">if</span> recv1[:<span class="number">3</span>] != <span class="string">&#x27;250&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;250 reply not received from server.&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Send MAIL FROM command and print server response.</span></span><br><span class="line"><span class="comment"># Fill in start</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill in end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Send RCPT TO command and print server response.</span></span><br><span class="line"><span class="comment"># Fill in start</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill in end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Send DATA command and print server response.</span></span><br><span class="line"><span class="comment"># Fill in start</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill in end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Send message data.</span></span><br><span class="line"><span class="comment"># Fill in start</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill in end </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Message ends with a single period.</span></span><br><span class="line"><span class="comment"># Fill in start</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill in end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Send QUIT command and get server response.</span></span><br><span class="line"><span class="comment"># Fill in start</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fill in end</span></span><br></pre></td></tr></table></figure><h2 id="可选练习"><a href="#可选练习" class="headerlink" title="可选练习"></a>可选练习</h2><ol><li><p>邮件服务器，例如谷歌邮件（<em><strong>address: smtp.gmail.com</strong></em>，<em><strong>port: 587</strong></em>）出于身份鉴定和安全的原因，需要你的客户端在发送 <code>MAIL FROM</code> 命令之前，添加一个传输层安全协议（<em><strong>TLS</strong></em>）或者一个安全套接字层（<em><strong>SSL</strong></em>）。添加 <em><strong>TLS&#x2F;SSL</strong></em> 到你现有的代码中，并使用上述的地址和端口为谷歌邮件服务器实现一个客户端。</p></li><li><p>目前你的 <em><strong>STMP</strong></em> 邮件客户端只能在电子邮件正文中发送文本信息。修改你的客户端使其既能发送文本信息又能发送图片。</p></li></ol><h2 id="必做题"><a href="#必做题" class="headerlink" title="必做题"></a>必做题</h2><p>由于 <em><strong>AT</strong></em> 立场的存在，本文采用的邮件服务器均为 <em><strong>QQ</strong></em> 邮箱来完成。通过实现一个 <em><strong>SMTP</strong></em> 客户端，使用 <em><strong>QQ</strong></em> 邮箱作为发件人，向指定的另一个 <em><strong>QQ</strong></em> 邮箱用户发送一封邮件。</p><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><p><em><strong>SMTP</strong></em> 客户端程序发送邮件的基本流程如下：</p><ol><li>与 <em><strong>QQ</strong></em> 邮件服务器建立起 <em><strong>TCP</strong></em> 连接，域名为 <code>smtp.qq.com</code> , <em><strong>QQ</strong></em> 邮箱官方提供的 <em><strong>SMTP</strong></em> 默认端口号为 <code>587</code> 。成功建立起连接后服务器返回状态码 <code>220</code>，代表服务器已经就绪。</li><li>发送 <code>HELO</code> 命令，客户端开始与服务器进行交互，服务器返回状态码 <code>250</code> （代表请求动作正确完成）。</li><li>发送 <code>AUTH LOGIN</code> 命令，开始验证身份，服务器返回状态码 <code>334</code> （服务器等待用户输入验证信息）。</li><li>发送经过 <em><strong>base64</strong></em> 编码的用户名，即你的邮箱账号，服务器返回状态码 <code>334</code> （服务器等待用户输入验证信息）。</li><li>发送经过 <em><strong>base64</strong></em> 编码的密码，（这里请注意该密码不是我们平常所用的密码，而是特殊的授权码，具体我会在后面说明），服务器返回状态码 <code>235</code> （用户验证成功）。</li><li>发送 <code>MAIL FROM</code> 命令，并包含发件人的邮箱地址，服务器将返回状态码 <code>250</code> （请求动作正确完成）。</li><li>发送 <code>RCPT TO</code> 命令，并包含收件人的邮箱地址，服务器将返回状态码 <code>250</code> （请求动作正确完成）。</li><li>发送 <code>DATA</code> 命令，表示即将发送邮件的内容，服务器将返回状态码 <code>354</code>。</li><li>发送邮件内容，以 <code>&lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;</code> 结束，服务器返回状态码 <code>250</code> （代表请求动作正确完成）。</li><li>发送 <code>QUIT</code> 命令，断开与 <em><strong>QQ</strong></em> 邮件服务器的连接。</li></ol><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ul><li>目前大多数邮箱都默认关闭了 <em><strong>SMTP</strong></em> 服务，例如 <em><strong>QQ</strong></em> 邮箱。我们需要进入 <em><strong>QQ</strong></em> 邮箱在设置中手动打开 <em><strong>SMTP</strong></em> 服务。在打开的同时，我们可以申请到一个授权码，在程序中我们使用这个授权码作为密码登录，而非平常的密码。</li><li>上文中的第 <em><strong>3、4、5</strong></em> 步在课本中并未提及，这也是因为 <em><strong>SMTP</strong></em> 服务被默认关闭了的原因，因此需要我们手动验证。</li><li><em><strong>SMTP</strong></em> 服务的默认端口号可以在官方查询得到。<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221121234812.png"></li></ul><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><p><em><strong>SMTPClient.py：</strong></em></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line">msg = <span class="string">&quot;\r\n I love computer networks!&quot;</span></span><br><span class="line">endmsg = <span class="string">&quot;\r\n.\r\n&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Choose a mail server (e.g. Google mail server) and call it mailserver </span></span><br><span class="line">mailServer = <span class="string">&quot;smtp.qq.com&quot;</span></span><br><span class="line">mailPort = <span class="number">587</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sender and reciever</span></span><br><span class="line">fromAddres = <span class="string">&quot;senderName@qq.com&quot;</span></span><br><span class="line">toAddres = <span class="string">&quot;recvName@qq.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create socket called clientSocket and establish a TCP connection with mailserver</span></span><br><span class="line"><span class="comment">#Fill in start</span></span><br><span class="line">clientSocket = socket(AF_INET, SOCK_STREAM) </span><br><span class="line">clientSocket.connect((mailServer, mailPort))</span><br><span class="line"><span class="comment">#Fill in end</span></span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv, end = <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> recv[:<span class="number">3</span>] != <span class="string">&#x27;220&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;220 reply not received from server.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Send HELO command and print server response.</span></span><br><span class="line">heloCommand = <span class="string">&#x27;HELO Alice\r\n&#x27;</span>.encode()</span><br><span class="line">clientSocket.send(heloCommand)</span><br><span class="line">recv1 = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv1, end = <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> recv1[:<span class="number">3</span>] != <span class="string">&#x27;250&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;250 reply not received from server.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Auth information (Encode with base64)</span></span><br><span class="line">userName = base64.b64encode(fromAddres.encode()).decode()</span><br><span class="line">password = base64.b64encode(<span class="string">&quot;magicNumber&quot;</span>.encode()).decode()</span><br><span class="line"></span><br><span class="line">clientSocket.sendall(<span class="string">&#x27;AUTH LOGIN\r\n&#x27;</span>.encode())</span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv, end = <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> (recv[:<span class="number">3</span>] != <span class="string">&#x27;334&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;334 reply not received from server&#x27;</span>)</span><br><span class="line"></span><br><span class="line">clientSocket.sendall((userName + <span class="string">&#x27;\r\n&#x27;</span>).encode())</span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv, end = <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> (recv[:<span class="number">3</span>] != <span class="string">&#x27;334&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;334 reply not received from server&#x27;</span>)</span><br><span class="line"></span><br><span class="line">clientSocket.sendall((password + <span class="string">&#x27;\r\n&#x27;</span>).encode())</span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv, end = <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> (recv[:<span class="number">3</span>] != <span class="string">&#x27;235&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;235 reply not received from server&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Send MAIL FROM command and print server response.</span></span><br><span class="line"><span class="comment"># Fill in start</span></span><br><span class="line">clientSocket.sendall((<span class="string">&quot;MAIL FROM: &lt;&quot;</span> + fromAddres + <span class="string">&quot;&gt;&quot;</span> + <span class="string">&#x27;\r\n&#x27;</span>).encode())</span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv, end = <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> (recv[:<span class="number">3</span>] != <span class="string">&#x27;250&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;250 reply not received from server&#x27;</span>)</span><br><span class="line"><span class="comment"># Fill in end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Send RCPT TO command and print server response.</span></span><br><span class="line"><span class="comment"># Fill in start</span></span><br><span class="line">clientSocket.sendall((<span class="string">&quot;RCPT TO: &lt;&quot;</span> + toAddres + <span class="string">&quot;&gt;&quot;</span> + <span class="string">&#x27;\r\n&#x27;</span>).encode())</span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv, end = <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> (recv[:<span class="number">3</span>] != <span class="string">&#x27;250&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;250 reply not received from server&#x27;</span>)</span><br><span class="line"><span class="comment"># Fill in end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Send DATA command and print server response.</span></span><br><span class="line"><span class="comment"># Fill in start</span></span><br><span class="line">clientSocket.sendall(<span class="string">&quot;DATA\r\n&quot;</span>.encode())</span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv, end = <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> (recv[:<span class="number">3</span>] != <span class="string">&#x27;354&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;354 reply not received from server&#x27;</span>)</span><br><span class="line"><span class="comment"># Fill in end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Send message data.</span></span><br><span class="line"><span class="comment"># Fill in start</span></span><br><span class="line">clientSocket.sendall((msg).encode())</span><br><span class="line"><span class="comment"># Fill in end </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Message ends with a single period.</span></span><br><span class="line"><span class="comment"># Fill in start</span></span><br><span class="line">clientSocket.sendall(endmsg.encode())</span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv, end = <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> (recv[:<span class="number">3</span>] != <span class="string">&#x27;250&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;250 reply not received from server&#x27;</span>)</span><br><span class="line"><span class="comment"># Fill in end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Send QUIT command and get server response.</span></span><br><span class="line"><span class="comment"># Fill in start</span></span><br><span class="line">clientSocket.sendall(<span class="string">&quot;QUIT\r\n&quot;</span>.encode())</span><br><span class="line">recv = clientSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line"><span class="built_in">print</span>(recv, end = <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> (recv[:<span class="number">3</span>] != <span class="string">&#x27;221&#x27;</span>):</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;221 reply not received from server&#x27;</span>)</span><br><span class="line"><span class="comment"># Fill in end</span></span><br><span class="line"></span><br><span class="line">clientSocket.close()</span><br></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p>运行正常的话，你将会正确收到服务器返回的每条信息，期中包含了状态码：<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221122002248.png"></p><p><em><strong>发送端邮箱：</strong></em><br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221122002521.png"></p><p><em><strong>接收端邮箱：</strong></em><br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221122002739.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络自顶向下 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SocketPA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wireshark-DNS</title>
      <link href="/archives/a94cdcd7.html"/>
      <url>/archives/a94cdcd7.html</url>
      
        <content type="html"><![CDATA[<p><em><strong>官方英文资源网站</strong></em> ：<a href="https://media.pearsoncmg.com/ph/esm/ecs_kurose_compnetwork_8/cw/"><em><strong>Pearson Computer Networking: a Top-Down Approach, 8th Edition</strong></em></a></p><p><em><strong>直接下载</strong></em>：<a href="https://www-net.cs.umass.edu/wireshark-labs/"><em><strong>Wireshark Labs</strong></em></a></p><p>由于英文原版的 <em><strong>PDF</strong></em> 的翻译任务有点大，所以这里只展示需要提交的内容，至于翻译先放进 <em><strong>TODO</strong></em> 里吧呜呜</p><hr><h2 id="Wireshark-实验-DNS-v7-0"><a href="#Wireshark-实验-DNS-v7-0" class="headerlink" title="Wireshark 实验:  DNS v7.0"></a>Wireshark 实验:  DNS v7.0</h2><p><strong>《计算机网络：自顶向下方法（第7版）》补充材料，J.F. Kurose and K.W. Ross</strong><br>“不闻不若闻之，闻之不若见之，见之不若知之，知之不若行之。” ——中国谚语 </p><p>© 2005-2012, J.F Kurose and K.W. Ross, All Rights Reserved</p><h2 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h2><p><em><strong>Q1</strong></em> : 运行 <em><strong>nslookup</strong></em> 以获取一个亚洲的 <em><strong>Web</strong></em> 服务器的 <em><strong>IP</strong></em> 地址。该服务器的 <em><strong>IP</strong></em> 地址是什么？<br><em><strong>A</strong></em> : 这里我查询的是厦门大学（<code>www.xmu.edu.cn</code>） 的 <em><strong>IP</strong></em> 地址：<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221111170006.png"><br>从图中可以看出我这里用的本地的 <em><strong>DNS</strong></em> 来获取厦门大学的 <em><strong>IP</strong></em> 地址。厦门大学分别有 <em><strong>IPV4</strong></em> 地址（<code>219.229.81.200</code>）和 <em><strong>IPV6</strong></em> 地址（<code>2001:da8:e800:251c::200</code>)，以及下面是他的别名，因为别名往往更好记住，所以我们一般都使用的是他的别名。</p><p>至于为什么叫非权威应答：因为我使用的本地 <em><strong>DNS</strong></em> 在没有缓存的情况下，我们只能递归或者迭代地向 <em><strong>DNS</strong></em> 根服务器、<em><strong>TLD DNS</strong></em> 服务器 和权威 <em><strong>DNS</strong></em> 服务器查询并且返回。</p><p>由于我们不是直接向权威 <em><strong>DNS</strong></em> 服务器查询的，中间的查询路径可能会有缓存，因此叫做非权威应答。</p><hr><p><em><strong>Q2</strong></em> : 运行 <em><strong>nslookup</strong></em> 来确定一个欧洲的大学的权威 <em><strong>DNS</strong></em> 服务器。<br><em><strong>A</strong></em> : 首先我们要知道使用 <code>-type=NS</code> 选项其实就是在说 “请给我发送 xxx 的权威 <em><strong>DNS</strong></em> 的主机名” ，理解这点就好办了。我这里请求查询了牛津大学的权威 <em><strong>DNS</strong></em> 服务器，返回的结果如下：<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221111174111.png"></p><p>所有这些都是牛津大学的权威 <em><strong>DNS</strong></em> 服务器。</p><hr><p><em><strong>Q3</strong></em> : 运行 <em><strong>nslookup</strong></em>，使用问题2中一个已获得的 <em><strong>DNS</strong></em> 服务器，来查询 <em><strong>Yahoo!</strong></em> 邮箱的邮件服务器。它的 <em><strong>IP</strong></em> 地址是什么？<br><em><strong>A</strong></em> : 使用牛津大学的权威 <em><strong>DNS</strong></em> 服务器是查不到的：<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221111174611.png" alt="原因是该权威服务器并没有 mail.yahoo.com 到 IP 的映射"></p><p>但我们可以用默认的本地 <em><strong>DNS</strong></em> 服务器查找到 <code>mail.yahoo.com</code> 的 <em><strong>IP</strong></em> 地址：<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221111174917.png"></p><h2 id="ipconfig"><a href="#ipconfig" class="headerlink" title="ipconfig"></a>ipconfig</h2><p><em><strong>ipconfig</strong></em>（对于 <em><strong>Windows</strong></em> ）和 <em><strong>ifconfig</strong></em>（对于 <em><strong>Linux &#x2F; Unix</strong></em>）是主机中最实用的程序，尤其是用于调试网络问题时。这里我们只讨论 <em><strong>ipconfig</strong></em>，尽管 <em><strong>Linux &#x2F; Unix</strong></em> 的 <em><strong>ifconfig</strong></em> 与其非常相似。 <em><strong>ipconfig</strong></em> 可用于显示您当前的 <em><strong>TCP&#x2F;IP</strong></em> 信息，包括您的地址，<em><strong>DNS</strong></em> 服务器地址，适配器类型等。</p><p><em><strong>ipconfig</strong></em> 对于管理主机中存储的 <em><strong>DNS</strong></em> 信息也非常有用。在第2.5节中，我们了解到主机可以缓存最近获得的 <em><strong>DNS</strong></em> 记录。要查看这些缓存记录，可以使用下面两条命令：</p><ol><li><p><code>ipconfig /displaydns</code><br>显示每个条目剩余的生存时间</p></li><li><p><code>ipconfig /flushdns</code><br>清除所有 <em><strong>DNS</strong></em> 缓存并从 <em><strong>hosts</strong></em> 重新加载缓存记录</p></li></ol><h2 id="使用Wireshark追踪DNS"><a href="#使用Wireshark追踪DNS" class="headerlink" title="使用Wireshark追踪DNS"></a>使用Wireshark追踪DNS</h2><p><em><strong>Q4</strong></em> : 找到 <em><strong>DNS</strong></em> 查询和响应消息。它们是否通过 <em><strong>UDP</strong></em> 或 <em><strong>TCP</strong></em> 发送？<br><em><strong>A</strong></em> : 通过 <em><strong>UDP</strong></em> 发送<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221112144958.png"></p><hr><p><em><strong>Q5</strong></em> : <em><strong>DNS</strong></em> 查询消息的目标端口是什么？<em><strong>DNS</strong></em> 响应消息的源端口是什么？<br><em><strong>A</strong></em> : 目标端口和源端口都是 <em><strong>53</strong></em><br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221112145503.png"></p><hr><p><em><strong>Q6</strong></em> : <em><strong>DNS</strong></em> 查询消息发送到哪个 <em><strong>IP</strong></em> 地址？使用 <em><strong>ipconfig</strong></em> 来确定本地 <em><strong>DNS</strong></em> 服务器的 <em><strong>IP</strong></em> 地址。这两个 <em><strong>IP</strong></em> 地址是否相同？<br><em><strong>A</strong></em> : 查询消息发到了 <code>192.168.31.1</code> 这个 <em><strong>IP</strong></em> 地址上。<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221112150057.png"><br>用 <em><strong>ipconfig</strong></em> 查到的本地 <em><strong>DNS</strong></em> 服务器的 <em><strong>IP</strong></em> 地址为：<code>192.168.31.1</code>，是同一个地址。<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221112150340.png"></p><hr><p><em><strong>Q7</strong></em> : 检查 <em><strong>DNS</strong></em> 查询消息。<em><strong>DNS</strong></em> 查询是什么” <em><strong>Type</strong></em> “的？查询消息是否包含任何” <em><strong>answers</strong></em> “？<br><em><strong>A</strong></em> : <em><strong>Type</strong></em> 为 <em><strong>A</strong></em>，不包含任何 <em><strong>answers</strong></em> 信息。<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221112150743.png"></p><hr><p><em><strong>Q8</strong></em> : 检查 <em><strong>DNS</strong></em> 响应消息。提供了多少个” <em><strong>answers</strong></em> “？这些答案具体包含什么？<br><em><strong>A</strong></em> : 提供了三个 <em><strong>answers</strong></em>，分别是由国外 <em><strong>CDN</strong></em> 厂商 <em><strong>Cloudflare</strong></em> 提供的规范 <em><strong>CNAME</strong></em> 的 <em><strong>CDN</strong></em> 加速（<em><strong>type&#x3D;CNAME</strong></em>）地址，以及规范后 <em><strong>CNAME</strong></em> 的两个 <em><strong>IPV4</strong></em> 地址（<em><strong>type&#x3D;A</strong></em>）。<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221112155343.png"></p><hr><p><em><strong>Q9</strong></em> : 考虑从您主机发送的后续 <em><strong>TCP SYN</strong></em> 数据包。<em><strong>SYN</strong></em> 数据包的目的 <em><strong>IP</strong></em> 地址是否与 <em><strong>DNS</strong></em> 响应消息中提供的任何 <em><strong>IP</strong></em> 地址相对应？<br><em><strong>A</strong></em> : 是对应的<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221112160514.png"></p><hr><p><em><strong>Q10</strong></em> : 这个网页包含一些图片。在获取每个图片前，您的主机是否都发出了新的DNS查询？现在让我们玩玩 <em><strong>nslookup</strong></em>。</p><ul><li>启动数据包捕获</li><li>使用 <em><strong>nslookup</strong></em> 查询 <code>www.mit.edu</code></li><li>停止数据包捕获</li></ul><p><em><strong>A</strong></em> : 从图可以看出我们发出了三个 <em><strong>DNS</strong></em> 查询，但只有后两个是新的 <em><strong>DNS</strong></em> 查询，第一个因为已经有缓存了所以直接使用的是本地 <em><strong>DNS</strong></em> 服务器中的地址。<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221112161621.png"></p><hr><p><em><strong>Q11</strong></em> : <em><strong>DNS</strong></em> 查询消息的目标端口是什么？ <em><strong>DNS</strong></em> 响应消息的源端口是什么？<br><em><strong>A</strong></em> : 目标端口和源端口还是53。<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221112162120.png"></p><hr><p><em><strong>Q12</strong></em> : <em><strong>DNS</strong></em> 查询消息的目标 <em><strong>IP</strong></em> 地址是什么？这是你的默认本地 <em><strong>DNS</strong></em> 服务器的 <em><strong>IP</strong></em> 地址吗？<br><em><strong>A</strong></em> : 跟上面一样，都是 <code>192.168.31.1</code></p><hr><p><em><strong>Q13</strong></em> : 检查 <em><strong>DNS</strong></em> 查询消息。<em><strong>DNS</strong></em> 查询是什么”<em><strong>Type</strong></em>“的？查询消息是否包含任何”<em><strong>answers</strong></em>“？<br><em><strong>A</strong></em> : <em><strong>TYPE&#x3D;A</strong></em>（请求 <em><strong>IPV4</strong></em> 地址查询），<em><strong>TYPE&#x3D;AAAA</strong></em>(请求 <em><strong>IPV6</strong></em> 地址查询)，查询消息不包括任何答案。<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221112162646.png"></p><hr><p><em><strong>Q14</strong></em> : 检查 <em><strong>DNS</strong></em> 响应消息。提供了多少个”<em><strong>answers</strong></em>“？这些答案包含什么？<br><em><strong>A</strong></em> : 同样包括规范主机地址（ <em><strong>type&#x3D;CNAME</strong></em> ），规范主机地址指向 <em><strong>IPV4</strong></em> （<em><strong>type&#x3D;A</strong></em>）和 <em><strong>IPV6</strong></em>（<em><strong>type&#x3D;AAAA</strong></em>）地址。<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221112162930.png"></p><hr><p><em><strong>Q15</strong></em> : 提供屏幕截图<br><em><strong>A</strong></em> : 截图在每一个题中</p><hr><p>现在重复上一个实验，但换成以下命令：<br><code>nslookup -type=NS mit.edu</code></p><p><em><strong>Q16</strong></em> : <em><strong>DNS</strong></em> 查询消息的目标 <em><strong>IP</strong></em> 地址是什么？这是你的默认本地 <em><strong>DNS</strong></em> 服务器的 <em><strong>IP</strong></em> 地址吗？<br><em><strong>A</strong></em> : 是的</p><hr><p><em><strong>Q17</strong></em> : 检查 <em><strong>DNS</strong></em> 查询消息。<em><strong>DNS</strong></em> 查询是什么”<em><strong>Type</strong></em>“的？查询消息是否包含任何”<em><strong>answers</strong></em>“？<br><em><strong>A</strong></em> : 有一个 <em><strong>TYPE&#x3D;PTR</strong></em>（通过 <em><strong>IP</strong></em> 反向查域名）和一个 <em><strong>TYPE&#x3D;NS</strong></em>（查询权威 <em><strong>DNS</strong></em>）请求，查询消息均不包含任何结果, <em><strong>PTR</strong></em> 应该是通过 <em><strong>IP</strong></em> 查询到我本地的 <em><strong>DNS</strong></em> 的域名。<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221112163653.png" alt="TYPE=PTR"></p><p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221112163800.png" alt="TYPE=NS"></p><p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221112163917.png" alt="通过 TYPE=PTR 查询域名"></p><hr><p><em><strong>Q18</strong></em> : 检查 <em><strong>DNS</strong></em> 响应消息。响应消息提供的 <em><strong>MIT</strong></em> 域名服务器是什么？此响应消息还提供了 <em><strong>MIT</strong></em> 域名服务器的 <em><strong>IP</strong></em> 地址吗？<br><em><strong>A</strong></em> : 提供了 <em><strong>MIT</strong></em> 的权威 <em><strong>DNS</strong></em> 的域名，但没有提供 <em><strong>MIT</strong></em> 的域名的 <em><strong>IP</strong></em> 地址。但一个有趣的事实是 <em><strong>nslookup</strong></em> 提供了 <em><strong>IP</strong></em> 地址。<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221112164323.png" alt="DNS 包"></p><p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221112164351.png" alt="nslookup"></p><hr><p><em><strong>Q19</strong></em> : 提供屏幕截图<br><em><strong>A</strong></em> : 截图在每一个题中</p><hr><p>现在重复上一个实验，但换成以下命令：<br><code>nslookup www.aiit.or.kr bitsy.mit.edu</code></p><p><em><strong>Q20</strong></em> : <em><strong>DNS</strong></em> 查询消息发送到的 <em><strong>IP</strong></em> 地址是什么？这是您的默认本地 <em><strong>DNS</strong></em> 服务器的 <em><strong>IP</strong></em> 地址吗？如果不是，这个 <em><strong>IP</strong></em> 地址是什么？<br><em><strong>A</strong></em> : 不是，该 <em><strong>IP</strong></em> 地址是：<code>18.0.72.3</code><br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221112165100.png"></p><hr><p><em><strong>Q21</strong></em> : 检查 <em><strong>DNS</strong></em> 查询消息。<em><strong>DNS</strong></em> 查询是什么” <em><strong>Type</strong></em> “的？查询消息是否包含任何” <em><strong>answers</strong></em> “？<br><em><strong>A</strong></em> : 跟上一个实验一致</p><hr><p><em><strong>Q22</strong></em> : 检查 <em><strong>DNS</strong></em> 响应消息。提供了多少个” <em><strong>answers</strong></em> “？这些答案包含什么？<br><em><strong>A</strong></em> : 由于我这边查询的时候 <em><strong>DNS</strong></em> 超时，故没有 <em><strong>DNS</strong></em> 响应消息。</p><hr><p><em><strong>Q23</strong></em> : 提供屏幕截图<br><em><strong>A</strong></em> : 截图在每一个题中</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络自顶向下 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Wireshark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wireshark-HTTP</title>
      <link href="/archives/b551ba0b.html"/>
      <url>/archives/b551ba0b.html</url>
      
        <content type="html"><![CDATA[<p><em><strong>官方英文资源网站</strong></em> ：<a href="https://media.pearsoncmg.com/ph/esm/ecs_kurose_compnetwork_8/cw/"><em><strong>Pearson Computer Networking: a Top-Down Approach, 8th Edition</strong></em></a></p><p><em><strong>直接下载</strong></em>：<a href="https://www-net.cs.umass.edu/wireshark-labs/"><em><strong>Wireshark Labs</strong></em></a></p><p>由于英文原版的 <em><strong>PDF</strong></em> 的翻译任务有点大，所以这里只展示需要提交的内容，至于翻译先放进 <em><strong>TODO</strong></em> 里吧呜呜</p><hr><h2 id="Wireshark-实验-HTTP-v7-0"><a href="#Wireshark-实验-HTTP-v7-0" class="headerlink" title="Wireshark 实验:  HTTP v7.0"></a>Wireshark 实验:  HTTP v7.0</h2><p><strong>《计算机网络：自顶向下方法（第7版）》补充材料，J.F. Kurose and K.W. Ross</strong><br>“不闻不若闻之，闻之不若见之，见之不若知之，知之不若行之。” ——中国谚语 </p><p>© 2005-2012, J.F Kurose and K.W. Ross, All Rights Reserved</p><h2 id="基本HTTP-GET-x2F-response交互"><a href="#基本HTTP-GET-x2F-response交互" class="headerlink" title="基本HTTP GET&#x2F;response交互"></a>基本HTTP GET&#x2F;response交互</h2><p><em><strong>Q1</strong></em> : 您的浏览器是否运行 <em><strong>HTTP</strong></em> 版本 <em><strong>1.0</strong></em> 或 <em><strong>1.1</strong></em> ？服务器运行什么版本的 <em><strong>HTTP</strong></em> ？<br><em><strong>A</strong></em> : 浏览器运行的是 <em><strong>1.1</strong></em>，服务器运行的也是 <em><strong>1.1</strong></em>。<br>从 <em><strong>GET</strong></em> 请求报文可以查看浏览器版本：<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221105163402.png"><br>从响应报文可以查看浏览器版本：<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221105163036.png"></p><hr><p><em><strong>Q2</strong></em> : 您的浏览器会从接服务器接受哪种语言（如果有的话）？<br><em><strong>A</strong></em> : 能接收到简体中文和英文。<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221105163256.png"></p><hr><p><em><strong>Q3</strong></em> : 您的计算机的 <em><strong>IP</strong></em> 地址是什么？ <em><strong>gaia.cs.umass.edu</strong></em> 服务器地址呢？<br><em><strong>A</strong></em> : 由上图可知，我的计算机的 <em><strong>IP</strong></em> 地址是：<code>192.168.43.92</code>; 服务器的 <em><strong>IP</strong></em> 地址是：<code>128.119.245.12</code></p><hr><p><em><strong>Q4</strong></em> : 服务器返回到浏览器的状态代码是什么？<br><em><strong>A</strong></em> : 由上图可知，状态码是 <code>304</code> 。</p><hr><p><em><strong>Q5</strong></em> : 服务器上HTML文件的最近一次修改是什么时候？<br><em><strong>A</strong></em> : 由于返回的是 <code>304</code> 状态码，故查看不到上一次修改的时间。</p><hr><p><em><strong>Q6</strong></em> : 服务器返回多少字节的内容到您的浏览器？<br><em><strong>A</strong></em> : 293 字节<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221105164732.png"></p><hr><p><em><strong>Q7</strong></em> : 通过检查数据包内容窗口中的原始数据，你是否看到有协议头在数据包列表窗口中未显示？ 如果是，请举一个例子。<br><em><strong>A</strong></em> : 没有，仅有这两条 <em><strong>HTTP</strong></em> 报文。</p><h2 id="HTTP条件Get-x2F-response交互"><a href="#HTTP条件Get-x2F-response交互" class="headerlink" title="HTTP条件Get&#x2F;response交互"></a>HTTP条件Get&#x2F;response交互</h2><p><em><strong>Q8</strong></em> : 检查第一个从您浏览器到服务器的 <em><strong>HTTP GET</strong></em> 请求的内容。您在 <em><strong>HTTP GET</strong></em>中看到了 <em><strong>“IF-MODIFIED-SINCE”</strong></em> 行吗？<br><em><strong>A</strong></em> : 如下图，没有看到。<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221105170136.png"></p><hr><p><em><strong>Q9</strong></em> : 检查服务器响应的内容。服务器是否显式返回文件的内容？ 你是怎么知道的？<br><em><strong>A</strong></em> : 有。直接看响应报文的 <em><strong>entity body</strong></em> 即可。<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221105170801.png"></p><hr><p><em><strong>Q10</strong></em> : 现在，检查第二个 <em><strong>HTTP GET</strong></em> 请求的内容。 您在 <em><strong>HTTP GET</strong></em> 中看到了 <em><strong>“IF-MODIFIED-SINCE:”</strong></em> 行吗？ 如果是， <em><strong>“IF-MODIFIED-SINCE:”</strong></em> 头后面包含哪些信息？<br><em><strong>A</strong></em> : 看到了。后面的值刚好就是上次得到的服务器最后修改这个文件的时间。<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221105171625.png"></p><hr><p><em><strong>Q11</strong></em> : 针对第二个 <em><strong>HTTP GET</strong></em> ，从服务器响应的 <em><strong>HTTP</strong></em> 状态码和短语是什么？服务器是否明确地返回文件的内容？请解释。<br><em><strong>A</strong></em> : 状态码是<code>304</code>，短语是 <code>Not Modified</code>。服务器并不会明确地返回文件的内容，如下图可以看到我们并没有具体的 <em><strong>entity body</strong></em> 。<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221105172144.png"></p><p>因为服务器返回 <code>304</code> 状态码说明我们请求的文件并没有被修改，所以服务器会让我们去缓存中取得该文件，因此服务器并不会明确地返回文件的内容。至于服务器如何判断缓存中的文件和服务器上的文件是否有差异，是因为我们在第二次 <em><strong>HTTP GET</strong></em> 请求中含有上次得到的服务器最后修改这个文件的时间，也就是 <em><strong>“IF-MODIFIED-SINCE:”</strong></em> 。服务器通过比较这两个时间来判断文件是否已经同步，从而避免了不必要的文件传输。</p><h2 id="检索长文件"><a href="#检索长文件" class="headerlink" title="检索长文件"></a>检索长文件</h2><p><em><strong>Q12</strong></em> : 您的浏览器发送多少 <em><strong>HTTP GET</strong></em> 请求消息？哪个数据包包含了美国权利法案的消息？<br><em><strong>A</strong></em> : 我的浏览器发送了一个 <em><strong>HTTP GET</strong></em> 报文，其中 1919 号数据包包含了美国权利法案的消息。<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221105174648.png"></p><hr><p><em><strong>Q13</strong></em> : 哪个数据包包含响应HTTP GET请求的状态码和短语？<br><em><strong>A</strong></em> : 由上图可知，同样是由 1919 号数据包包含了响应的状态码： <code>200</code>，短语为：<code>OK</code> 。</p><hr><p><em><strong>Q14</strong></em> : 响应中的状态码和短语是什么？<br><em><strong>A</strong></em> : 同上题。</p><hr><p><em><strong>Q15</strong></em> : 需要多少包含数据的 <em><strong>TCP</strong></em> 段来执行单个 <em><strong>HTTP</strong></em> 响应和权利法案文本？<br><em><strong>A</strong></em> : 需要4个。<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221105175513.png"></p><h2 id="具有嵌入对象的HTML文档"><a href="#具有嵌入对象的HTML文档" class="headerlink" title="具有嵌入对象的HTML文档"></a>具有嵌入对象的HTML文档</h2><p><em><strong>Q16</strong></em> : 您的浏览器发送了几个 <em><strong>HTTP GET</strong></em> 请求消息？ 这些 <em><strong>GET</strong></em> 请求发送到哪个IP地址？<br><em><strong>A</strong></em> : 发送了三个，其中有两个请求的 <em><strong>IP</strong></em> 地址：<code>128.119.245.12</code> 和 <code>178.79.137.164</code> 。<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221105180145.png"></p><hr><p><em><strong>Q17</strong></em> : 浏览器从两个网站串行还是并行下载了两张图片？请说明。<br><em><strong>A</strong></em> : 观察上图后两个 <em><strong>HTTP GET</strong></em> 请求消息的发出时间可以发现，这两个报文的时间并没有重叠，而是有先后的，因此可以判断并非是并行下载。</p><h2 id="HTTP认证"><a href="#HTTP认证" class="headerlink" title="HTTP认证"></a>HTTP认证</h2><p><em><strong>Q18</strong></em> : 对于您的浏览器的初始 <em><strong>HTTP GET</strong></em> 消息，服务器响应（状态码和短语）是什么响应？<br><em><strong>A</strong></em> : 状态码：<code>401</code>；短语：<code>Unauthorized</code> ，即未授权，需要登录才能访问。<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221105181502.png"></p><hr><p><em><strong>Q19</strong></em> : 当您的浏览器第二次发送 <em><strong>HTTP GET</strong></em> 消息时，<em><strong>HTTP GET</strong></em> 消息中包含哪些新字段？<br><em><strong>A</strong></em> : 多了 <em><strong>Authorization</strong></em> 字段，即授权字段，其中包含了我们的账户和密码。<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221105182257.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络自顶向下 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Wireshark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake学习笔记</title>
      <link href="/archives/9f9ceb8.html"/>
      <url>/archives/9f9ceb8.html</url>
      
        <content type="html"><![CDATA[<p>作为一名 <em><strong>C&#x2F;C++</strong></em> 的开发者，其实在很早之前已经知道 <em><strong>CMake</strong></em> 的存在了。最近正好由于课业的要求，要求使用 <em><strong>CMake</strong></em>，故借此来系统地学习一下 <em><strong>CMake</strong></em>。</p><p>本篇博客的内容是我学习小彭老师的视频时所做的笔记，如有侵权请及时联系我。</p><p>下面是小彭老师视频的链接：<a href="https://www.bilibili.com/video/BV16P4y1g7MH/?spm_id_from=333.337.search-card.all.click&vd_source=2652d832108fec04c7b16fcf850e5ca7">【公开课】现代CMake高级教程（持续更新中）</a></p><h2 id="初识CMake"><a href="#初识CMake" class="headerlink" title="初识CMake"></a>初识CMake</h2><ul><li><p>官网：<a href="https://www.cmake.org/"><em><strong>www.cmake.org</strong></em></a></p></li><li><p>特点：</p><ol><li>开放源代码，使用类 <em><strong>BSD</strong></em> 许可发布。<a href="http://cmake.org/HTML/Copyright.html"><em><strong>http://cmake.org/HTML/Copyright.html</strong></em></a></li><li>跨平台，并可生成 <em><strong>native</strong></em> 编译配置文件，在 <em><strong>Linux&#x2F;Unix</strong></em> 平台，生成 <em><strong>makefile</strong></em> ，在苹果平台，可以生成 <em><strong>xcode</strong></em> ，在 <em><strong>Windows</strong></em> 平台，可以生成 <em><strong>MSVC</strong></em> 的工程文件。</li><li>能够管理大型项目。</li><li>简化编译构建过程和编译过程。</li><li>高效虑，主要是因为 <em><strong>CMake</strong></em> 在工具链中没有 <em><strong>libtool</strong></em>。</li><li>可扩展，可以为 <em><strong>CMake</strong></em> 编写特定功能的模块，扩充 <em><strong>CMake</strong></em> 功能。</li></ol></li><li><p>不足：</p><ol><li><em><strong>CMake</strong></em> 绝对没有听起来或者想象中那么简单。</li><li><em><strong>CMake</strong></em> 编写的过程实际上是编程的过程，每个目录有一个 <em><strong>CMakeLists.txt</strong></em>，使用的是 <em><strong>CMake</strong></em> 语言和语法。</li><li><em><strong>CMake</strong></em> 跟已有体系的配合并不是特别理想，比如 <em><strong>pkgconfig</strong></em> 。</li></ol></li></ul><h2 id="安装CMake"><a href="#安装CMake" class="headerlink" title="安装CMake"></a>安装CMake</h2><p>我本人使用的环境是 <em><strong>Ubuntu 20.04</strong></em> ，对于 <em><strong>Linux&#x2F;Unix</strong></em> 平台的用户下载的方法应该都是大同小异。</p><p>在我的环境只需要一行命令行即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install cmake</span><br></pre></td></tr></table></figure><h2 id="CMake的helloworld"><a href="#CMake的helloworld" class="headerlink" title="CMake的helloworld"></a>CMake的helloworld</h2><p>首先你需要建立一个目录，该目录下有两个文件：<em><strong>main.cpp</strong></em> 和 <em><strong>CMakeLists.txt</strong></em>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CMake-practice</span><br><span class="line">└── template</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── main.cpp</span><br></pre></td></tr></table></figure><p>为了方便管理你的练习代码，建议你将练习代码集中放置在一起。</p><p><em><strong>main.cpp</strong></em> 的内容为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em><strong>CMakeLists.txt</strong></em> 的内容为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.15)</span><br><span class="line">project(hellocmake)</span><br><span class="line"></span><br><span class="line">find_program(CCACHE_PROGRAM ccache)</span><br><span class="line">if (CCACHE_PROGRAM)</span><br><span class="line">    message(STATUS &quot;Found CCache: $&#123;CCACHE_PROGRAM&#125;&quot;)</span><br><span class="line">    set_property(GLOBAL PROPERTY RULE_LAUNCH_COMPILE $&#123;CCACHE_PROGRAM&#125;)</span><br><span class="line">    set_property(GLOBAL PROPERTY RULE_LAUNCH_LINK $&#123;CCACHE_PROGRAM&#125;)</span><br><span class="line">endif()</span><br><span class="line"></span><br><span class="line">add_executable(main main.cpp)</span><br><span class="line"></span><br><span class="line">add_custom_target(run COMMAND $&lt;TARGET_FILE:main&gt;)</span><br><span class="line">if (CMAKE_EDIT_COMMAND)</span><br><span class="line">    add_custom_target(configure COMMAND $&#123;CMAKE_EDIT_COMMAND&#125; -B $&#123;CMAKE_BINARY_DIR&#125;)</span><br><span class="line">endif()</span><br></pre></td></tr></table></figure><p>以我的目录结构为例，在 <code>/template</code> 目录下执行 <code>cmake -B build</code>，你会看到这样的输出：<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221102204837.png"></p><p>然后项目中会多出一个 <code>/template/build</code> 目录，该目录中多出了这几个文件：<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221102205935.png"></p><p>接着在 <code>/template</code> 目录下执行 <code>cmake --build build</code>，你会看到这样的输出：<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221102205628.png"></p><p>此时<code>/template/build</code> 目录下会多出一个 <code>main</code> 可执行文件：<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221102205737.png"></p><p>我们就可以直接在<code>/template</code> 目录下执行 <code>build/main</code> 了：<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221102210159.png"></p><h2 id="命令行小技巧"><a href="#命令行小技巧" class="headerlink" title="命令行小技巧"></a>命令行小技巧</h2><p>从这里开始我们将一步一步讲解我们在 <em><strong>CMake</strong></em> 的 <em><strong>helloworld</strong></em> 里所作的命令行操作的含义，以及 <em><strong>CMakeLists.txt</strong></em> 该如何编写。</p><h3 id="B-和-build-指令，不同平台，统一命令"><a href="#B-和-build-指令，不同平台，统一命令" class="headerlink" title="-B 和 --build 指令，不同平台，统一命令"></a><code>-B</code> 和 <code>--build</code> 指令，不同平台，统一命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cmake -B build          // 在源码目录用 -B 直接创建 build 目录并生成 build/Makefile</span><br><span class="line"></span><br><span class="line">cmake --build build -j4 // 自动调用本地的构建系统在 build 里构建，在 linux 上就是：make -C build -j4</span><br><span class="line"></span><br><span class="line">sudo cmake --build build --target install  // 调用本地的构建系统执行 install 这个目标，即安装</span><br></pre></td></tr></table></figure><ul><li><code>cmake -B build</code> 免去了先构建 <em><strong>build</strong></em> 目录再切换进去再指定源码目录的麻烦。</li><li><code>cmake --build build</code> 统一了不同平台（ <em><strong>linux</strong></em> 上会调用 <em><strong>make</strong></em>，<em><strong>windows</strong></em> 上调用 <em><strong>devenv.exe</strong></em>）</li><li>结论：如果在命令行操作 <em><strong>cmake</strong></em>，请使用更方便的 <code>-B</code> 和 <code>--build</code> 指令。</li></ul><h3 id="D-选项：指定配置变量（又称缓存变量）"><a href="#D-选项：指定配置变量（又称缓存变量）" class="headerlink" title="-D 选项：指定配置变量（又称缓存变量）"></a><code>-D</code> 选项：指定配置变量（又称缓存变量）</h3><p>由上可知 <em><strong>CMake</strong></em> 项目的可分为两步走：</p><ol><li>第一步是 <code>cmake -B build</code>，称为配置阶段（<em><strong>configure</strong></em>），这时只是检测环-境并生成构建规则。会在 <em><strong>build</strong></em> 目录下生成本地构建系统能识别的项目文件（<em><strong>Makefile</strong></em> 或 <em><strong>.sln</strong></em>）</li><li>第二步是 <code>cmake --build build</code>，称为构建阶段（<em><strong>build</strong></em>），这时才实际调用编译器来编译代码。</li></ol><ul><li>在配置阶段可以通过 <code>-D</code> 设置缓存变量。第二次配置时，之前的 <code>-D</code> 添加仍然会被保留。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cmake -B build -DCMAKE_BUILD_TYPE=Release // 设置构建模式为发布模式（开启全部优化）</span><br><span class="line"></span><br><span class="line">cmake -B build  // 第二次配置时没有 -D 参数，但是之前 -D 设置的变量都会被保留</span><br></pre></td></tr></table></figure><ul><li>此时缓存里仍有我们之前定义的 <code>CMAKE_BUILD_TYPE</code>。</li></ul><h3 id="G-选项：指定要用的生成器"><a href="#G-选项：指定要用的生成器" class="headerlink" title="-G 选项：指定要用的生成器"></a><code>-G</code> 选项：指定要用的生成器</h3><p><em><strong>linux</strong></em> 系统上的 <em><strong>CMake</strong></em> 默认用 <em><strong>UNIX Makefiles</strong></em> 生成器；<em><strong>Windows</strong></em> 系统默认是 <em><strong>Visual Studio 2019</strong></em> 生成器；<em><strong>MacOS</strong></em> 系统默认是 <em><strong>Xcode</strong></em> 生成器。</p><p>可以用 <code>-G</code> 参数改用别的生成器，例如 <code>cmake -GNinja</code> 会生成 <em><strong>Ninja</strong></em> 这个构建系统的构建规则。<em><strong>Ninja</strong></em> 是一个高性能，跨平台的构建系统，三大主流平台上都可以用。<em><strong>Ninja</strong></em> 可以从包管理器安装，没有包管理器的 <em><strong>Windows</strong></em> 可以用 <em><strong>Python</strong></em> 的包管理器安装：<code>pip install ninja</code></p><p>事实上， <em><strong>MSBuild</strong></em> 是单核心的构建系统， <em><strong>Makefile</strong></em> 虽然多核心但因为历史兼容原因效率一般。而 <em><strong>Ninja</strong></em> 则是作为性能优化的构建系统，他和 <em><strong>CMake</strong></em> 结合都是行业标准了。</p><p>下面我们演示一下用 <code>cmake -GNinja</code> 生成 <em><strong>Ninja</strong></em>：<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221106223904.png"></p><h2 id="添加源文件"><a href="#添加源文件" class="headerlink" title="添加源文件"></a>添加源文件</h2><p>首先我们需要一个简单的 <code>.cpp</code> 源文件用于测试，就像我们在 <em><strong>CMake</strong></em> 的 <em><strong>helloworld</strong></em> 里所作的那样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在同级目录下新建一个 <em><strong>CMakeLists.txt</strong></em>，在 <em><strong>CMake</strong></em> 中添加一个可执行文件作为构建目标。</p><h3 id="创建并添加源文件"><a href="#创建并添加源文件" class="headerlink" title="创建并添加源文件"></a>创建并添加源文件</h3><ul><li>至于前两行我们可以暂且忽略，后面会介绍到的，我们只看第三条语句：<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221106225042.png"></li><li>我们可以看到 <code>add_executable(main main.cpp)</code> 这条语句，其中 <code>main</code> 就是生成的可执行文件的文件名，相当于 <em><strong>gcc</strong></em> 的 <em><strong>-o</strong></em> 选项，而在这之后跟着的就是源文件列表，你可以在这后面跟多个源文件。例如 <code>add_executable(main main.cpp xxx.cpp xxx.cpp)</code> 。</li></ul><h3 id="另一种方式：先创建目标，稍后添加源文件"><a href="#另一种方式：先创建目标，稍后添加源文件" class="headerlink" title="另一种方式：先创建目标，稍后添加源文件"></a>另一种方式：先创建目标，稍后添加源文件</h3><ul><li><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221106231348.png"></li><li>如果有多个源文件，我们也是在源文件列表里逐个添加即可：<code>target_sources(main PRIVATE main.cpp xxx.cpp xxx.cpp)</code>。</li><li>还有一个十分显眼的关键字 <em><strong>PRIVATE</strong></em>。这个关键字指出了这些对应的源应该在何处被使用，<em><strong>PRIVATE</strong></em> 表示这些源只应该添加到 <code>main</code> 中，这正是我们所期望的。</li><li>与之对应的还有 <em><strong>PUBLIC</strong></em> 关键字，<em><strong>PUBLIC</strong></em> 表示这些源应该添加到 <code>main</code> 和任何链接到 <code>main</code> 的对象中，这可不是我们通常想要的。但有一种例外，那就是头文件以及 <em><strong>header only</strong></em> 的库，我们可能总是希望把这些头文件传播到与 <code>main</code> 链接的对象中。</li><li>或许你可能还会问 <em><strong>INTERFACE</strong></em> 关键字呢，因为目前我们暂时没有用上这个关键字的场景，等我们以后碰上再说吧。</li></ul><h3 id="使用变量来存储"><a href="#使用变量来存储" class="headerlink" title="使用变量来存储"></a>使用变量来存储</h3><ul><li><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221106233634.png"></li><li>其中 <code>set(source main.cpp)</code> 就是定义变量的语句，<em><strong>source</strong></em> 是变量名，而在这之后的列表就是变量的内容。我们在访问变量时使用 <code>$&#123;source&#125;</code> 的语法，这样 <em><strong>source</strong></em> 就会把内容展开，其实就有点像宏替换的感觉。</li></ul><h3 id="使用-GLOB-实现批量添加源文件"><a href="#使用-GLOB-实现批量添加源文件" class="headerlink" title="使用 GLOB 实现批量添加源文件"></a>使用 <code>GLOB</code> 实现批量添加源文件</h3><ul><li><p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221113215121.png"></p></li><li><p>使用 <code>GLOB</code> 会自动查找当前目录下指定扩展名的文件，从而实现批量添加源文件的效果。但这种方式有一个缺点，那就是构建完成之后如果指定扩展名的文件添加或者删除了，<em><strong>cmake</strong></em> 并不会自动更新。</p></li><li><p>因此我们最好是启用 <code>CONFIGURE_DEPENDS</code> 选项，当添加新文件时，自动更新变量。<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221113220256.png"></p></li></ul><h3 id="使用-aux-source-directory-自动搜集需要的文件后缀名"><a href="#使用-aux-source-directory-自动搜集需要的文件后缀名" class="headerlink" title="使用 aux_source_directory 自动搜集需要的文件后缀名"></a>使用 <code>aux_source_directory</code> 自动搜集需要的文件后缀名</h3><ul><li><p>出于管理源码的需要，我们可能把代码放到当前目录下的一个子文件夹中，就像这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CMake-practice</span><br><span class="line">└── template</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    ├── main.cpp</span><br><span class="line">    └── mylib</span><br><span class="line">        └── mylib.cpp</span><br></pre></td></tr></table></figure></li><li><p>如果我们还是单纯地使用第 <em><strong>4</strong></em> 点中我们所用的命令，是不会将 <em><strong>mylib</strong></em> 文件夹中的所需文件加入进来的，因为 <code>GLOB</code> 只会查找当前目录下的文件，并不会进行递归查找。</p></li><li><p>当然我们也可以把路径名和后缀名的排列组合全部写出来，例如：<code>file(GLOB source CONFIGURE_DEPENDS *.cpp *.h mylib/*.cpp mylib/*.h)</code></p></li><li><p>但这样未免太过麻烦，这个时候 <code>aux_source_directory</code> 就十分方便了：<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221113222949.png"></p></li><li><p>我们这里指定了两个搜索目录，一个是当前目录，一个是 <em><strong>mylib</strong></em> 目录，<code>aux_source_directory</code> 会根据我们所使用的语言自动去搜索需要的文件。</p></li><li><p>当然 <code>aux_source_directory</code> 不是万能的，它本身并不具备检查更新的功能。</p></li></ul><h3 id="进一步：GLOB-RECURSE-递归查询子文件夹下的文件"><a href="#进一步：GLOB-RECURSE-递归查询子文件夹下的文件" class="headerlink" title="进一步：GLOB_RECURSE , 递归查询子文件夹下的文件"></a>进一步：<code>GLOB_RECURSE</code> , 递归查询子文件夹下的文件</h3><ul><li><p>我们首先需要修改一下项目结构，将源码全部放到 <em><strong>src</strong></em> 文件夹下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CMake-practice</span><br><span class="line">└── template</span><br><span class="line">    ├── build</span><br><span class="line">    ├── CMakeLists.txt</span><br><span class="line">    └── src</span><br><span class="line">        ├── main.cpp</span><br><span class="line">        └── mylib</span><br><span class="line">            └── mylib.cpp</span><br></pre></td></tr></table></figure></li><li><p>然后修改 <em><strong>CMakeLists.txt</strong></em> 为：<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221113231341.png"></p></li><li><p>之所以把源码移入 <em><strong>src</strong></em> 文件夹下，是因为如果源码和 <em><strong>build</strong></em> 文件夹在同一目录下，会把 <em><strong>build</strong></em> 文件夹下的一些中间文件也引入进来，这将可能导致意料外的错误。</p></li><li><p>因此最佳实践是把源码和 <em><strong>build</strong></em> 文件夹隔离开来，这样我们就得到了递归搜索文件和自动更新两大好处。</p><h2 id="项目配置变量"><a href="#项目配置变量" class="headerlink" title="项目配置变量"></a>项目配置变量</h2></li></ul>]]></content>
      
      
      <categories>
          
          <category> CMake </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CMake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Wireshark-Introduction</title>
      <link href="/archives/c3b21e39.html"/>
      <url>/archives/c3b21e39.html</url>
      
        <content type="html"><![CDATA[<p><em><strong>官方英文资源网站</strong></em> ：<a href="https://media.pearsoncmg.com/ph/esm/ecs_kurose_compnetwork_8/cw/"><em><strong>Pearson Computer Networking: a Top-Down Approach, 8th Edition</strong></em></a></p><p><em><strong>直接下载</strong></em>：<a href="https://www-net.cs.umass.edu/wireshark-labs/"><em><strong>Wireshark Labs</strong></em></a></p><p>由于英文原版的 <em><strong>PDF</strong></em> 的翻译任务有点大，所以这里只展示需要提交的内容，至于翻译先放进 <em><strong>TODO</strong></em> 里吧呜呜</p><hr><h2 id="Wireshark-实验-入门-v7-0"><a href="#Wireshark-实验-入门-v7-0" class="headerlink" title="Wireshark 实验:  入门 v7.0"></a>Wireshark 实验:  入门 v7.0</h2><p><strong>《计算机网络：自顶向下方法（第7版）》补充材料，J.F. Kurose and K.W. Ross</strong><br>“不闻不若闻之，闻之不若见之，见之不若知之，知之不若行之。” ——中国谚语 </p><p>© 2005-2012, J.F Kurose and K.W. Ross, All Rights Reserved</p><h2 id="获取Wireshark"><a href="#获取Wireshark" class="headerlink" title="获取Wireshark"></a>获取Wireshark</h2><p>为了运行 <em><strong>Wireshark</strong></em> ，您需要一台支持 <em><strong>Wireshark</strong></em> 和 <em><strong>libpcap</strong></em> 或 <em><strong>WinPCap</strong></em> 分组捕获库的计算机。当你安装 <em><strong>Wireshark</strong></em> 时，如果你的操作系统中未安装 <em><strong>libpcap</strong></em> 软件，它将会自动安装。</p><p>有关支持的操作系统和下载站点的列表，请访问：<a href="http://www.wireshark.org/download.html"><em><strong>http://www.wireshark.org/download.html</strong></em></a></p><p><em><strong>Wireshark</strong></em> <em><strong>FAQ</strong></em> 有一些有用的提示和有趣的信息，尤其是你在安装或运行 <em><strong>Wireshark</strong></em> 时遇到问题的时候。</p><h2 id="需要提交的内容"><a href="#需要提交的内容" class="headerlink" title="需要提交的内容"></a>需要提交的内容</h2><p>第一个实验的目的主要是向你介绍 <em><strong>Wireshark</strong></em> 。以下问题将证明你已经能够使 <em><strong>Wireshark</strong></em> 启动并运行，并且已经探索了其中一些功能。根据你的 <em><strong>Wireshark</strong></em> 实验回答以下问题：</p><ol><li><p>列出出现在未过滤的分组列表窗口的协议列中的3种不同的协议。<br>随便选其中几种：<em><strong>TCP</strong></em>、<em><strong>OICP</strong></em>、<em><strong>TLSv1.2</strong></em></p></li><li><p>从 <em><strong>HTTP GET</strong></em> 消息发送到 <em><strong>HTTP OK</strong></em> 回复需要多长时间？<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/InkedQQ%E5%9B%BE%E7%89%8720221021223929.jpg"><br>如图需要：<em><strong>0.413765 - 0.145155 &#x3D; 0.268610 s</strong></em></p></li><li><p><code>gaia.cs.umass.edu</code> (也称为 <code>wwwnet.cs.umass.edu</code> )的 <em><strong>Internet地址</strong></em> 是什么？你的计算机的 <em><strong>Internet</strong></em> 地址是什么？<br>参考上图可知 <code>gaia.cs.umass.edu</code> 的 <em><strong>IP</strong></em> 地址为：<code>128.119.245.12</code>，我自己的 <em><strong>IP</strong></em> 地址为了保密就不放出力。</p></li><li><p>打印问题2提到的两个 <em><strong>HTTP</strong></em> 消息(<em><strong>GET和OK</strong></em>)。要这样做，从 <em><strong>Wireshark</strong></em> 的“文件”菜单中选择“打印”，然后选择“仅选中分组”和“按当前显示”按钮，然后单击确定。<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221021225150.png"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络自顶向下 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Wireshark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SocketLab2：UDPping</title>
      <link href="/archives/ce10b13b.html"/>
      <url>/archives/ce10b13b.html</url>
      
        <content type="html"><![CDATA[<p><em><strong>官方英文资源网站</strong></em> ：<a href="https://media.pearsoncmg.com/ph/esm/ecs_kurose_compnetwork_8/cw/"><em><strong>Pearson Computer Networking: a Top-Down Approach, 8th Edition</strong></em></a></p><p><em><strong>直接下载</strong></em>：<a href="https://media.pearsoncmg.com/ph/esm/ecs_kurose_compnetwork_8/cw/content/python-socket-programming-assignments.zip"><em><strong>Python 3 Socket Programming Assignments</strong></em></a></p><p><em><strong>以下内容为笔者翻译</strong></em> ：</p><hr><p>在这个实验中，你将学习在 <em><strong>Python</strong></em> 使用 <em><strong>UDP</strong></em> 套接字编程的基础。你将学习到如何使用 <em><strong>UDP</strong></em> 套接字接收和发送数据报，以及如何设置一个合理的套接字超时。通过这个实验，你将会熟悉 <em><strong>Ping</strong></em> 应用程序及其在计算统计信息（如丢包率）中的作用。</p><p>你首先将会学习使用 <em><strong>Python</strong></em> 编写一个简单的互联网 <em><strong>Ping</strong></em> 服务器程序，并实现相关的客户端。这些程序提供的功能类似于现代操作系统中提供的可用的标准的 <em><strong>Ping</strong></em> 程序的功能。然而，这些程序使用一份更简单的 <em><strong>UDP</strong></em> 协议，而不是标准互联网信息控制协议（<em><strong>ICMP</strong></em>）来进行通信。<em><strong>Ping</strong></em> 协议允许一个客户端机器发送一个数据报给一个远程机器，并使远程机器返回数据到客户端机器（称为回显）的操作。在其他用途上，<em><strong>Ping</strong></em> 协议允许主机确认他到其他机器的往返时间。</p><p>下面已经为你给出了完整的 <em><strong>Ping</strong></em> 服务器代码。你的任务是编写 <em><strong>Ping</strong></em> 客户端代码。</p><h2 id="服务器代码"><a href="#服务器代码" class="headerlink" title="服务器代码"></a>服务器代码</h2><p>以下代码完整地实现了一个 <em><strong>Ping</strong></em> 服务器。你需要在运行你的客户端代码之前编译并运行这份服务器代码。你不需要修改这份代码。</p><p>在这份服务器代码中，30%的客户端的数据包会被模拟丢失。你应该仔细学习这份代码，它将帮助你思考如何编写 <em><strong>Ping</strong></em> 客户端程序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># UDPPingerServer.py </span></span><br><span class="line"><span class="comment"># We will need the following module to generate randomized lost packets import random </span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> * </span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a UDP socket  </span></span><br><span class="line"><span class="comment"># Notice the use of SOCK_DGRAM for UDP packets </span></span><br><span class="line">serverSocket = socket(AF_INET, SOCK_DGRAM) </span><br><span class="line"><span class="comment"># Assign IP address and port number to socket </span></span><br><span class="line">serverSocket.bind((<span class="string">&#x27;&#x27;</span>, <span class="number">12000</span>)) </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:     </span><br><span class="line"><span class="comment"># Generate random number in the range of 0 to 10 </span></span><br><span class="line">rand = random.randint(<span class="number">0</span>, <span class="number">10</span>)     </span><br><span class="line"><span class="comment"># Receive the client packet along with the address it is coming from  </span></span><br><span class="line">message, address = serverSocket.recvfrom(<span class="number">1024</span>) </span><br><span class="line"><span class="comment"># Capitalize the message from the client     </span></span><br><span class="line">message = message.upper() </span><br><span class="line"><span class="comment"># If rand is less is than 4, we consider the packet lost and do not respond     </span></span><br><span class="line"><span class="keyword">if</span> rand &lt; <span class="number">4</span>:         </span><br><span class="line"><span class="keyword">continue</span>     </span><br><span class="line"><span class="comment"># Otherwise, the server responds         </span></span><br><span class="line">serverSocket.sendto(message, address)</span><br></pre></td></tr></table></figure><p>服务器程序在一个死循环中监听到来的 <em><strong>UDP</strong></em> 数据包。当一个数据包到来时，如果生成一个随机数大于等于4，则服务器程序只需将数据包中的数据转换为大写并将其返回给客户端即可。</p><h2 id="丢包"><a href="#丢包" class="headerlink" title="丢包"></a>丢包</h2><p><em><strong>UDP</strong></em> 向应用程序提供一个不可信赖的传输服务。信息可能会丢失于网络之中，比如因为路由器缓存溢出、硬件故障或者其他的原因。但由于在内网中丢包是很罕见的甚至不存在的，所以本次实验中的服务器程序添加人为的丢包来模拟网络丢包的影响。服务器程序生成一个随机整数变量来确定传入的数据包是丢失还是不丢失。</p><h2 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h2><p>你需要实现以下的客户端程序。这个客户端程序应该发送10个 <em><strong>Ping</strong></em> 给服务器。因为 <em><strong>UDP</strong></em> 是一个不可信赖的协议，所以从一个从客户端发送到服务器的数据包可能会在网络中丢失，反之亦然。由于这个原因，客户端程序不能无限等待 <em><strong>Ping</strong></em> 消息的响应。你应该让客户端程序等待服务器回答的时间最多为一秒。如果一秒内没有收到响应，你的客户端程序应该假设该数据包在传输过程中已经丢失。您需要查阅 <em><strong>Python</strong></em> 文档，如何在一个数据包套接字上设置超时值。</p><p>具体来说，你的客户端程序应该：</p><ol><li>使用 <em><strong>UDP</strong></em> 来发送 <em><strong>Ping</strong></em> 信息。（注意：你不需要像 <em><strong>TCP</strong></em> 一样先建立连接，因为 <em><strong>UDP</strong></em> 是一个无连接协议）</li><li>输出来自服务器的响应。</li><li>如果收到来自服务器的响应，计算并打印出往返时间（<em><strong>RTT</strong></em>），以秒为单位。</li><li>否则，打印 <em><strong>“请求超时”</strong></em> 。</li></ol><p>在开发过程中，你应该在你的机器上运行 <code>UDPPingerServer.py</code> ，并通过向 <code>localhost</code> (或者 <code>127.0.0.1</code> ) 发送数据包测试你的客户端程序。在调试完成之后，你应该能够看到你的 <em><strong>Ping</strong></em> 服务器和 <em><strong>Ping</strong></em> 客户端在不同机器上通过网络进行通信。</p><h2 id="信息格式"><a href="#信息格式" class="headerlink" title="信息格式"></a>信息格式</h2><p>在这个实验中 <em><strong>Ping</strong></em> 消息格式使用最简单的方式。客户端信息只有一行，由以下格式的 <em><strong>ASCII</strong></em> 字符组成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ping sequence_number time</span><br></pre></td></tr></table></figure><p>其中 <em><strong>sequence_number</strong></em> 从1开始，一直到10，一共10条消息，而 <em><strong>time</strong></em> 则是客户端发送信息的时间。</p><h2 id="需要上交的内容"><a href="#需要上交的内容" class="headerlink" title="需要上交的内容"></a>需要上交的内容</h2><p>你需要上交完整的客户端代码和截图来证明你的 <em><strong>Ping</strong></em> 程序像要求的那样正常工作。</p><h2 id="可选练习"><a href="#可选练习" class="headerlink" title="可选练习"></a>可选练习</h2><ol><li>目前，程序为每个数据包单独地计算出往返时间（<em><strong>RTT</strong></em>）并打印出来。请按照标准的 <em><strong>Ping</strong></em> 程序的模式修改。你需要在客户端发送完所有 <em><strong>Ping</strong></em> 消息后报告最大，最小和平均的 <em><strong>RTT</strong></em>。另外，你还需要计算出此次的丢包率（使用百分比）。</li><li>另一个和 <em><strong>UDPPing</strong></em> 相似的应用程序是 <em><strong>UDPHeartbeat</strong></em> 。<em><strong>UDPHeartbeat</strong></em> 可以被用来检查一个应用程序是否已经启动且正在运行，并报告单向丢包率。客户端发送一个包含序列号和时间戳的 <em><strong>UDP</strong></em> 数据包到正在监听客户端心跳的服务器。当服务器收到数据包后，计算时间差，报告丢包率。如果心跳数据包在限定时间内丢失了，我们可以假设客户端程序已经停止运行了。实现 <em><strong>UDPHeartbeat</strong></em> （包括客户端和服务器端）。你需要修改提供给你的 <code>UDPPingerServer.py</code> 和你的 <em><strong>UDPPing</strong></em> 客户端程序。</li></ol><h2 id="必做题"><a href="#必做题" class="headerlink" title="必做题"></a>必做题</h2><p>为了格式好看一点，我这里选择让 <em><strong>sequence_number</strong></em> 从0开始，以9结束，一共10条 <em><strong>Ping</strong></em> 消息。</p><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">serverName = <span class="string">&#x27;Anya&#x27;</span></span><br><span class="line">serverPort = <span class="number">12000</span></span><br><span class="line">clientSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line">clientSocket.settimeout(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">    sendTime = time.time()</span><br><span class="line">    message = <span class="string">&#x27;Ping &#x27;</span> + <span class="built_in">str</span>(i) + <span class="string">&#x27; &#x27;</span> + time.asctime()</span><br><span class="line">    clientSocket.sendto(message.encode(), (serverName, serverPort))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        modifiedMessage, serverAddress = clientSocket.recvfrom(<span class="number">2048</span>)</span><br><span class="line">        rtt = time.time() - sendTime</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Sequence %d: %s    RTT = %.3fs&#x27;</span> % (i, modifiedMessage.decode(), rtt)) </span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Sequence %d: Request timed out&#x27;</span> % (i))</span><br><span class="line"></span><br><span class="line">clientSocket.close()</span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p><em><strong>服务器端：</strong></em><br>在一台主机上运行 <code>UDPPingerServer.py</code>，作为接收 <em><strong>Ping</strong></em> 程序的服务器：<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221020123157.png"></p><p><em><strong>客户端：</strong></em><br>在另一台主机上运行 <code>UDPPingerClient.py</code>，作为 <em><strong>Ping</strong></em> 程序的客户端：<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221020123533.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络自顶向下 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SocketPA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SocketLab1：WebServe</title>
      <link href="/archives/d13c898c.html"/>
      <url>/archives/d13c898c.html</url>
      
        <content type="html"><![CDATA[<p><em><strong>官方英文资源网站</strong></em> ：<a href="https://media.pearsoncmg.com/ph/esm/ecs_kurose_compnetwork_8/cw/"><em><strong>Pearson Computer Networking: a Top-Down Approach, 8th Edition</strong></em></a></p><p><em><strong>直接下载</strong></em>：<a href="https://media.pearsoncmg.com/ph/esm/ecs_kurose_compnetwork_8/cw/content/python-socket-programming-assignments.zip"><em><strong>Python 3 Socket Programming Assignments</strong></em></a></p><p><em><strong>以下内容为笔者翻译</strong></em> ：</p><hr><p>在这个实验中，你将学习在 <em><strong>Python</strong></em> 中使用 <em><strong>TCP</strong></em> 连接的套接字编程的基础：如何创建一个套接字，将其绑定在特定的地址和端口上，以及发送和接收一个 <em><strong>HTTP</strong></em> 数据包。此外你还将学习到一些关于 <em><strong>HTTP</strong></em> 头部格式的基础知识。</p><p>你将开发一个一次处理一个 <em><strong>HTTP</strong></em> 请求的 <em><strong>Web</strong></em> 服务器。你的 <em><strong>Web</strong></em> 服务器应该能够接收和解析 <em><strong>HTTP</strong></em> 请求，然后从服务器的文件系统中获取所请求的文件，创建一个由所请求文件组成的，首部行在前的 <em><strong>HTTP</strong></em> 响应报文，最后将响应直接发送给客户端。如果所请求的文件不存在于服务器中，则服务请应该向客户端发送一个 <em><strong>“404 Not Found”</strong></em> 的 <em><strong>HTTP</strong></em> 消息。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>在下面你会找到 <em><strong>Web</strong></em> 服务器的框架代码。你需要完善这个框架代码。那些你需要填写代码的地方已经使用 <code>#Fill in start</code> 和 <code>#Fill in end</code> 标记出来了。每个地方可能需要填写一至多行代码。</p><h2 id="运行服务器"><a href="#运行服务器" class="headerlink" title="运行服务器"></a>运行服务器</h2><p>将 <em><strong>HTML</strong></em> 文件（例如：<code>HelloWorld.html</code> ）放在服务器所在的目录。运行服务器程序。确认运行服务器的主机的 <em><strong>IP</strong></em> 地址（例如： <code>128.238.251.26</code> ）。从另外一个主机打开浏览器并提供相应的 <em><strong>URL</strong></em> 链接。</p><p>举个例子：<code>http://128.238.251.26:6789/HelloWorld.html</code></p><p><em><strong>‘HelloWorld.html’</strong></em> 是你放置在服务器目录的文件的名字。还要注意冒号后的端口号的使用。你需要将其替换成你在服务器代码中所使用的端口号。在上面的例子中，我们使用了 <em><strong>6789</strong></em> 这个端口号。浏览器应该显示 <code>HelloWorld.html</code> 的内容。如果你省去了 <em><strong>:6789</strong></em>，浏览器会假定使用默认端口号80，只有当你的服务器在监听80号端口时，你才能从服务器得到网页。</p><p>然后试图获取一个并不存在于服务器上的文件。你会收到一个 <em><strong>“404 Not Found”</strong></em> 的信息。</p><h2 id="需要上交的内容"><a href="#需要上交的内容" class="headerlink" title="需要上交的内容"></a>需要上交的内容</h2><p>你需要上交完整的服务器代码并附带客户端的浏览器截图，用于验证你确实从服务器接收到了 <em><strong>HTML</strong></em> 文件的内容。</p><h2 id="Web服务器的Python代码框架"><a href="#Web服务器的Python代码框架" class="headerlink" title="Web服务器的Python代码框架"></a>Web服务器的Python代码框架</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#import socket module</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">serverSocket = socket(AF_INET, SOCK_STREAM) </span><br><span class="line"><span class="comment">#Prepare a sever socket </span></span><br><span class="line"><span class="comment">#Fill in start </span></span><br><span class="line"><span class="comment">#Fill in end </span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:     </span><br><span class="line">    <span class="comment">#Establish the connection    </span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;Ready to serve...&#x27;</span>     </span><br><span class="line">    connectionSocket, addr =   <span class="comment">#Fill in start  #Fill in end</span></span><br><span class="line">    <span class="keyword">try</span>:         </span><br><span class="line">        message =   <span class="comment">#Fill in start  #Fill in end</span></span><br><span class="line">        filename = message.split()[<span class="number">1</span>]                          </span><br><span class="line">        f = <span class="built_in">open</span>(filename[<span class="number">1</span>:])</span><br><span class="line">        outputdata = <span class="comment">#Fill in start  #Fill in end</span></span><br><span class="line">        <span class="comment">#Send one HTTP header line into socket         </span></span><br><span class="line">        <span class="comment">#Fill in start         </span></span><br><span class="line">        <span class="comment">#Fill in end    </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#Send the content of the requested file to the client</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(outputdata)):</span><br><span class="line">            connectionSocket.send(outputdata[i])</span><br><span class="line">        connectionSocket.close()</span><br><span class="line">    <span class="keyword">except</span> IOError:</span><br><span class="line">        <span class="comment">#Send response message for file not found</span></span><br><span class="line">        <span class="comment">#Fill in start</span></span><br><span class="line">        <span class="comment">#Fill in end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#Close client socket</span></span><br><span class="line">        <span class="comment">#Fill in start</span></span><br><span class="line">        <span class="comment">#Fill in end             </span></span><br><span class="line">    serverSocket.close()</span><br></pre></td></tr></table></figure><h2 id="可选练习"><a href="#可选练习" class="headerlink" title="可选练习"></a>可选练习</h2><ol><li><p>目前，这个 <em><strong>Web</strong></em> 服务器只支持一次处理一个 <em><strong>HTTP</strong></em> 请求。请实现一个能够同时处理多个请求的多线程服务器。使用线程，首先创建一个主线程在固定端口监听客户端请求。当收到一个从客户端发来的 <em><strong>TCP</strong></em> 连接请求，它将通过另一个端口建立 <em><strong>TCP</strong></em> 连接，并在另外的单独线程为客户端请求提供服务。这样每一对请求&#x2F;响应组都会有一个独立的线程提供独立的 <em><strong>TCP</strong></em> 连接。</p></li><li><p>不使用浏览器，而是编写你自己的 <em><strong>HTTP</strong></em> 客户端来测试你的服务器。你的客户端将会通过 <em><strong>TCP</strong></em> 来连接服务器，发送一个 <em><strong>HTTP</strong></em> 请求到服务器，并将服务器响应作为输出来展示。你可以假设发送的 <em><strong>HTTP</strong></em> 请求使用 <em><strong>GET</strong></em> 方法。客户端应该使用命令行参数来指定服务器 <em><strong>IP</strong></em> 地址或主机名，和服务器正在监听的端口号，还有被请求对象被装载在服务器上的路径。以下是运行客户端的输入命令格式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client.py server_host server_port filename</span><br></pre></td></tr></table></figure></li></ol><h2 id="必做题"><a href="#必做题" class="headerlink" title="必做题"></a>必做题</h2><p>由于我没有两台电脑，所以我采用的是用虚拟机作为服务器，物理机作为客户端的方法进行实验的，亲测可行。</p><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><p><code>WebServer.py</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#import socket module</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">serverSocket = socket(AF_INET, SOCK_STREAM) </span><br><span class="line"><span class="comment">#Prepare a sever socket </span></span><br><span class="line"><span class="comment">#Fill in start </span></span><br><span class="line">serverSocket.bind((<span class="string">&#x27;&#x27;</span>, <span class="number">1300</span>)) <span class="comment"># Bind the TCP welcome socket to the default port</span></span><br><span class="line">serverSocket.listen(<span class="number">1</span>)</span><br><span class="line"><span class="comment">#Fill in end </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;The serve is ready to receive.&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:     </span><br><span class="line">    <span class="comment">#Establish the connection    </span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Ready to serve...&#x27;</span>)   </span><br><span class="line">    connectionSocket, addr = serverSocket.accept()</span><br><span class="line">    <span class="keyword">try</span>:         </span><br><span class="line">        message = connectionSocket.recv(<span class="number">1024</span>).decode()</span><br><span class="line">        filename = message.split()[<span class="number">1</span>]                          </span><br><span class="line">        f = <span class="built_in">open</span>(filename[<span class="number">1</span>:])</span><br><span class="line">        outputdata = f.read()</span><br><span class="line">        <span class="comment">#Send one HTTP header line into socket         </span></span><br><span class="line">        <span class="comment">#Fill in start     </span></span><br><span class="line">        header = <span class="string">&#x27; HTTP/1.1 200 OK\nConnection: close\nContent-Type: text/html\nContent-Length: %d\n\n&#x27;</span> % (<span class="built_in">len</span>(outputdata)) </span><br><span class="line">        connectionSocket.send(header.encode())   </span><br><span class="line">        <span class="comment">#Fill in end    </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#Send the content of the requested file to the client</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(outputdata)):</span><br><span class="line">            connectionSocket.send(outputdata[i].encode())</span><br><span class="line">        connectionSocket.close()</span><br><span class="line">    <span class="keyword">except</span> IOError:</span><br><span class="line">        <span class="comment">#Send response message for file not found</span></span><br><span class="line">        <span class="comment">#Fill in start</span></span><br><span class="line">        header = <span class="string">&#x27; HTTP/1.1 404 Not Found&#x27;</span></span><br><span class="line">        connectionSocket.send(header.encode())   </span><br><span class="line">        <span class="comment">#Fill in end</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#Close client socket</span></span><br><span class="line">        <span class="comment">#Fill in start</span></span><br><span class="line">        connectionSocket.close()</span><br><span class="line">        <span class="comment">#Fill in end             </span></span><br><span class="line">serverSocket.close()</span><br></pre></td></tr></table></figure><p><code>HelloWorld.html</code>:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p><em><strong>服务器端：</strong></em><br>在一台主机的同一目录下放上 <code>WebServer.py</code> 和 <code>HelloWorld.html</code> 两个文件，并运行 <code>WebServer.py</code> 作为服务器。<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221016093057.png"></p><p><em><strong>客户端：</strong></em><br>在另一台主机的浏览器上输入 <code>http://XXX.XXX.XXX.XXX:1300/HelloWorld.html</code> (其中 <em><strong>XXX.XXX.XXX.XXX</strong></em> 是你所选择的服务器的 <em><strong>IP</strong></em> 地址)<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221016093614.png"></p><p>如果输入 <code>http://XXX.XXX.XXX.XXX:1300/Nothing.html</code>，来尝试获取服务器并不存在的文件 <code>Nothing.html</code>，将会收到一个 <em><strong>HTTP ERROR 404</strong></em> 信息：<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221016093928.png"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络自顶向下 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SocketPA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PA3实验笔记</title>
      <link href="/archives/7c883405.html"/>
      <url>/archives/7c883405.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>PA是NJU ICS的课程实验，作为一个非科班的学生，要完成这个实验属实不易，但是在这个过程中我收获到的知识和经验无疑是我求学路上无比宝贵的财富。为了记录下这宝贵的经历，故写此博客记录下我的苦恼与感悟。在这篇博客里我会简单叙述我的思路和踩过的坑。<strong><em>另外特此声明，如果您本身需要独自完成PA实验，为了学术诚信，请自行完成后再参考本博客，今日偷的懒，在未来会加倍偿还！</em></strong></p><h1 id="最简单的操作系统"><a href="#最简单的操作系统" class="headerlink" title="最简单的操作系统"></a>最简单的操作系统</h1><p>在 <strong><em>PA</em></strong> 中使用的操作系统叫 <strong><em>Nanos-lite</em></strong> , 它是南京大学操作系统 <strong><em>Nanos</em></strong> 的裁剪版。是一个为 <strong><em>PA</em></strong> 量身订造的操作系统。  </p><p><strong><em>Nanos-lite</em></strong> 是运行在 <strong><em>AM</em></strong> 之上, <strong><em>AM</em></strong> 的 <strong><em>API</em></strong> 在 <strong><em>Nanos-lite</em></strong> 中都是可用的。虽然操作系统对我们来说是一个特殊的概念, 但在 <strong><em>AM</em></strong> 看来, 它只是一个调用 <strong><em>AM API</em></strong> 的 <strong><em>普通C程序</em></strong> 而已, 和超级玛丽没什么区别。</p><p>目前我们的操作系统的功能还十分简陋，但我们可以先运行一下它来看看 <strong><em>logo</em></strong>：</p><p>在 <strong><em>nanos-lite/</em></strong> 目录下执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=<span class="variable">$ISA</span>-nemu run</span><br></pre></td></tr></table></figure><br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/5$Z3_0QW5`BEANL7UD@SJ(V.png" alt=""></p><p>如果你没能顺利出现 <strong><em>Nanos-lite</em></strong> 的 <strong><em>logo</em></strong>，大概是还有一些指令你没有实现。相信都到这个阶段了，实现指令对你来说应该不成问题。</p><p>还有一个不那么容易察觉到的坑，就是输出 <strong><em>logo</em></strong> 时实际会调用我们 <strong><em>klib</em></strong> 中的 <strong><em>printf</em></strong>。如果你给 <strong><em>printf</em></strong> 设置的内置 <strong><em>buf</em></strong> 不够大，很可能会出现缓冲区溢出的情况，从而出现跟 <strong><em>ref</em></strong> 完全不同的行为。</p><h1 id="穿越时空的旅程"><a href="#穿越时空的旅程" class="headerlink" title="穿越时空的旅程"></a>穿越时空的旅程</h1><p><strong><em>riscv32</em></strong> 提供 <strong><em>ecall</em></strong> 指令作为自陷指令, 并提供一个 <strong><em>mtvec</em></strong> 寄存器来存放异常入口地址。为了保存程序当前的状态, <strong><em>riscv32</em></strong> 提供了一些特殊的系统寄存器, 叫 <strong><em>控制状态寄存器(CSR寄存器)</em></strong> 。在 <strong><em>PA</em></strong> 中, 我们只使用如下3个 <strong><em>CSR</em></strong> 寄存器:</p><ul><li><strong><em>mepc</em></strong> 寄存器 - 存放触发异常的PC</li><li><strong><em>mstatus</em></strong> 寄存器 - 存放处理器的状态</li><li><strong><em>mcause</em></strong> 寄存器 - 存放触发异常的原因</li></ul><p><strong><em>riscv32</em></strong> 触发异常后硬件的响应过程如下:</p><ol><li>将当前 <strong><em>PC</em></strong> 值保存到 <strong><em>mepc</em></strong> 寄存器</li><li>在 <strong><em>mcause</em></strong> 寄存器中设置异常号</li><li>从 <strong><em>mtvec</em></strong> 寄存器中取出异常入口地址</li><li>跳转到异常入口地址</li></ol><p>等到异常处理结束之后, 就根据之前保存的信息恢复程序的状态, 并从异常处理过程中返回到程序触发异常之前的状态. 具体地：</p><ul><li><strong><em>riscv32</em></strong> 通过 <strong><em>mret</em></strong> 指令从异常处理过程中返回, 它将根据 <strong><em>mepc</em></strong> 寄存器恢复 <strong><em>PC</em></strong>。</li></ul><h1 id="将上下文管理抽象成CTE"><a href="#将上下文管理抽象成CTE" class="headerlink" title="将上下文管理抽象成CTE"></a>将上下文管理抽象成CTE</h1><p>我们可以将上下文管理的功能划入到 <strong><em>AM</em></strong> 的一类新的 <strong><em>API</em></strong> 中, 名字叫 <strong><em>CTE(ConText Extension)</em></strong> 。</p><h2 id="触发自陷操作"><a href="#触发自陷操作" class="headerlink" title="触发自陷操作"></a>触发自陷操作</h2><p>为了测试异常入口地址是否已经设置正确, 我们还需要真正触发一次自陷操作。定义了宏 <strong><em>HAS_CTE</em></strong> 后, <strong><em>Nanos-lite</em></strong> 会在 <strong><em>panic()</em></strong> 前调用 <strong><em>yield()</em></strong> 来触发自陷操作。</p><p>为了支撑这次自陷操作, 你需要在 <strong><em>NEMU</em></strong> 中实现 <strong><em>isa_raise_intr()</em></strong> 函数 <strong><em>(在nemu/src/isa/$ISA/system/intr.c中定义)</em></strong> 来模拟上文提到的异常响应机制。</p><p>具体地，如何判断我们进入了正确的异常入口地址。让我们具体地看看 <strong><em>cte_init</em></strong> 是如何设置异常入口地址的。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;csrw mtvec, %0&quot;</span> : : <span class="string">&quot;r&quot;</span>(__am_asm_trap))</span>;</span><br></pre></td></tr></table></figure><br>这里涉及了一点内联汇编的知识，简单来说就是把 <strong><em>__am_asm_trap</em></strong> 的函数地址赋给 <strong><em>%0</em></strong>，然后再执行这条汇编语句。这个时候 <strong><em>mtvec</em></strong> 就正确地被设置上了异常处理函数地入口地址，至此 <strong><em>OS</em></strong>  完成了注册异常入口地址的行为。</p><p>因此我们只需要观察程序是否进入到了 <strong><em>__am_asm_trap</em></strong> 内部即可。</p><h2 id="保存上下文"><a href="#保存上下文" class="headerlink" title="保存上下文"></a>保存上下文</h2><p>这部分的任务需要我们根据 <strong><em>trap.S</em></strong> 的汇编内容重新组织 <strong><em>Context结构体</em></strong>。简单来说就是理解 <strong><em>riscv32</em></strong> 在汇编层面上结构体是如何存放在栈中的。</p><p><strong><em>Context结构体</em></strong>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Context</span> &#123;</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> fix the order of these members to match trap.S</span></span><br><span class="line">  <span class="type">uintptr_t</span> gpr[<span class="number">32</span>], mcause, mstatus, mepc;</span><br><span class="line">  <span class="type">void</span> *pdir;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>汇编：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#define concat_temp(x, y) x ## y</span><br><span class="line">#define concat(x, y) concat_temp(x, y)</span><br><span class="line">#define MAP(c, f) c(f)</span><br><span class="line"></span><br><span class="line">#if __riscv_xlen == 32</span><br><span class="line">#define LOAD  lw</span><br><span class="line">#define STORE sw</span><br><span class="line">#define XLEN  4</span><br><span class="line">#else</span><br><span class="line">#define LOAD  ld</span><br><span class="line">#define STORE sd</span><br><span class="line">#define XLEN  8</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#define REGS(f) \</span><br><span class="line">      f( 1)       f( 3) f( 4) f( 5) f( 6) f( 7) f( 8) f( 9) \</span><br><span class="line">f(10) f(11) f(12) f(13) f(14) f(15) f(16) f(17) f(18) f(19) \</span><br><span class="line">f(20) f(21) f(22) f(23) f(24) f(25) f(26) f(27) f(28) f(29) \</span><br><span class="line">f(30) f(31)</span><br><span class="line"></span><br><span class="line">#define PUSH(n) STORE concat(x, n), (n * XLEN)(sp);</span><br><span class="line">#define POP(n)  LOAD  concat(x, n), (n * XLEN)(sp);</span><br><span class="line"></span><br><span class="line">#define CONTEXT_SIZE  ((32 + 3 + 1) * XLEN)</span><br><span class="line">#define OFFSET_SP     ( 2 * XLEN)</span><br><span class="line">#define OFFSET_CAUSE  (32 * XLEN)</span><br><span class="line">#define OFFSET_STATUS (33 * XLEN)</span><br><span class="line">#define OFFSET_EPC    (34 * XLEN)</span><br><span class="line"></span><br><span class="line">.align 3</span><br><span class="line">.globl __am_asm_trap</span><br><span class="line">__am_asm_trap:</span><br><span class="line">  addi sp, sp, -CONTEXT_SIZE</span><br><span class="line"></span><br><span class="line">  MAP(REGS, PUSH)</span><br><span class="line"></span><br><span class="line">  csrr t0, mcause</span><br><span class="line">  csrr t1, mstatus</span><br><span class="line">  csrr t2, mepc</span><br><span class="line"></span><br><span class="line">  STORE t0, OFFSET_CAUSE(sp)</span><br><span class="line">  STORE t1, OFFSET_STATUS(sp)</span><br><span class="line">  STORE t2, OFFSET_EPC(sp)</span><br></pre></td></tr></table></figure></p><p>简单对比一下就可以发现在 <strong><em>trap.S</em></strong> 里是先塞32个通用寄存器，再塞 <strong><em>mcause</em></strong>，然后塞 <strong><em>mstatus</em></strong>，最后塞 <strong><em>mepc</em></strong> 的。</p><p>我们只需要保证结构体中是按这个顺序排放变量的即可。</p><h2 id="事件分发"><a href="#事件分发" class="headerlink" title="事件分发"></a>事件分发</h2><p>这个其实很简单，我们只需要康康文档就可以了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man 2 syscall</span><br></pre></td></tr></table></figure><br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/L}B~K[TY5~MI~BZH(_08D`M.png" alt=""></p><p>从文档中我们可以看到 <strong><em>RISCV</em></strong> 的 <strong><em>abi</em></strong> 规约，<strong><em>a7</em></strong> 寄存器就是用来存放异常号的。知道了这点事件分发就没什么困难的了。</p><h2 id="恢复上下文"><a href="#恢复上下文" class="headerlink" title="恢复上下文"></a>恢复上下文</h2><p>代码将会一路从 <strong><em>__am_irq_handle()</em></strong> 返回到 <strong><em>trap.S</em></strong> 的  <strong><em>__am_asm_trap()</em></strong> 中, 接下来的事情就是恢复程序的上下文。</p><p>对于 <strong><em>mips32</em></strong> 的 <strong><em>syscall</em></strong> 和 <strong><em>riscv32</em></strong> 的 <strong><em>ecall</em></strong> , 保存的是自陷指令的 <strong><em>PC</em></strong> , 因此需要在适当的地方对保存的 <strong><em>PC</em></strong> 加上4, 使得将来返回到自陷指令的下一条指令。</p><div class="note primary modern"><p><strong><em>从加 4 操作看 CISC 和 RISC</em></strong><br>我们必须要考虑，决定要不要加4的操作到底是交给硬件来做还是软件来做呢？ <strong><em>CISC</em></strong> 和 <strong><em>RISC</em></strong> 的做法正好相反, <strong><em>CISC</em></strong> 都交给硬件来做, 而 <strong><em>RISC</em></strong> 则交给软件来做。</p></div><p>可不要小看了这里的区别，如果你没有仔细阅读这里的话，那么你的 <strong><em>difftest</em></strong> 多半是过不去的。个中缘由还请你好好思考一下。</p><h2 id="异常处理的踪迹-etrace"><a href="#异常处理的踪迹-etrace" class="headerlink" title="异常处理的踪迹 - etrace"></a>异常处理的踪迹 - etrace</h2><p>这个跟我们前面实现的 <strong><em>trace</em></strong> 没什么区别，不是什么难题。</p><h1 id="用户程序和系统调用"><a href="#用户程序和系统调用" class="headerlink" title="用户程序和系统调用"></a>用户程序和系统调用</h1><p>现在我们来解决实现批处理系统的第二个问题: 如何加载用户程序。</p><h2 id="加载第一个用户程序"><a href="#加载第一个用户程序" class="headerlink" title="加载第一个用户程序"></a>加载第一个用户程序</h2><p>在操作系统中, 加载用户程序是由 <strong><em>loader(加载器)</em></strong> 模块负责的。加载的过程就是把可执行文件中的代码和数据放置在正确的内存位置, 然后跳转到程序入口, 程序就开始执行了。简单来说，实现 <strong><em>loader</em></strong> 的最大困难就在于如何解析 <strong><em>ELF</em></strong> 文件。弄懂了这点，实现 <strong><em>loader</em></strong> 就没什么困难了。</p><p>当然，要加载用户程序，首先得解决用户程序从哪里来的问题。用户程序运行在操作系统之上, 由于运行时环境的差异, 我们不能把编译到 <strong><em>AM</em></strong> 上的程序放到操作系统上运行。这是因为我们不能把 <strong><em>AM（驱动层）</em></strong> 的接口直接暴露给用户，否则就太危险了。为此, 我们准备了一个新的子项目<br><strong><em>Navy-apps</em></strong> , 专门用于编译出操作系统的用户程序。</p><p>用户程序的入口位于 <code>navy-apps/libs/libos/src/crt0/start/$ISA.S</code> 中的 <strong><em>_start()</em></strong> 函数, 这里的 <strong><em>crt</em></strong> 是 <strong><em>C RunTime</em></strong> 的缩写, 0的含义表示最开始. <strong><em>_start()</em></strong> 函数会调用 <code>navy-apps/libs/libos/src/crt0/crt0.c</code> 中的 <strong><em>call_main()</em></strong> 函数, 然后调用用户程序的 <strong><em>main()</em></strong> 函数, 从 <strong><em>main()</em></strong> 函数返回后会调用 <strong><em>exit()</em></strong> 结束运行。</p><p>这其实跟真实的 <strong><em>linux</em></strong> 执行 <strong><em>c</em></strong> 程序的过程非常的相似，也大致描述了正常的 <strong><em>c</em></strong> 程序的入口函数其实并非 <strong><em>main()</em></strong> 函数。</p><p>让我们先来梳理一下实现 <strong><em>loader</em></strong> 需要解决的问题：</p><ol><li>可执行文件在哪里?</li><li>代码和数据在可执行文件的哪个位置?</li><li>代码和数据有多少?</li><li>“正确的内存位置”在哪里?</li></ol><p>第一个问题已经可以解决了，重点在第二第三个问题上。我们必须要弄明白可执行文件的结构，才能正确的加载用户程序。由于我们是在 <strong><em>linux</em></strong> 上做的实验，所以我们需要了解的可执行文件格式就是 <strong><em>ELF</em></strong> 。</p><p>什么是 <strong><em>ELF</em></strong> ？简单来说 <strong><em>ELF</em></strong> 就是描述程序状态机初始状态的一个数据结构。</p><p>让我们先来看看典型的 <strong><em>ELF</em></strong> 可执行文件的结构是什么样的：<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/OCAY`93CYPB]SP`O40TQAQW.png" alt=""><br>我们可以看到 <strong><em>ELF</em></strong> 可执行文件主要就是由两部分，<strong><em>section</em></strong> 和 <strong><em>segment</em></strong> 组成。其中一些 <strong><em>section</em></strong> 被称为 <strong><em>table</em></strong> ，<strong><em>table</em></strong> 可以被用来索引 <strong><em>segment</em></strong> 的，并存储一些额外的信息。</p><p><strong><em>ELF中</em></strong> 采用 <strong><em>program header table</em></strong> 来管理 <strong><em>segment</em></strong> , <strong><em>program header table</em></strong> 的一个表项描述了一个 <strong><em>segment</em></strong> 的所有属性, 包括类型, 虚拟地址, 标志, 对齐方式, 以及文件内偏移量和 <strong><em>segment</em></strong> 大小。我们可以通过判断 <strong><em>segment</em></strong> 的 <strong><em>Type</em></strong> 属性是否为 <strong><em>PT_LOAD</em></strong> 来判断一个 <strong><em>segment</em></strong> 是否需要加载。</p><p>当然这些概念具体是如何体现在代码上的，我们可以使用一个方便的库 <strong><em><elf.h></em></strong> 来展示：</p><p><strong><em><elf.h></em></strong> 提供了一个叫做 <strong><em>Elf64_Ehdr</em></strong> 的结构体，其实就对应了上图中的 <strong><em>ELF头</em></strong> ：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span>e_ident[EI_NIDENT];<span class="comment">/* Magic number and other info */</span></span><br><span class="line">  Elf64_Halfe_type;  <span class="comment">/* Object file type */</span></span><br><span class="line">  Elf64_Halfe_machine;<span class="comment">/* Architecture */</span></span><br><span class="line">  Elf64_Worde_version;<span class="comment">/* Object file version */</span></span><br><span class="line">  Elf64_Addre_entry;  <span class="comment">/* Entry point virtual address */</span></span><br><span class="line">  Elf64_Offe_phoff;  <span class="comment">/* Program header table file offset */</span></span><br><span class="line">  Elf64_Offe_shoff;  <span class="comment">/* Section header table file offset */</span></span><br><span class="line">  Elf64_Worde_flags;  <span class="comment">/* Processor-specific flags */</span></span><br><span class="line">  Elf64_Halfe_ehsize;  <span class="comment">/* ELF header size in bytes */</span></span><br><span class="line">  Elf64_Halfe_phentsize;<span class="comment">/* Program header table entry size */</span></span><br><span class="line">  Elf64_Halfe_phnum;  <span class="comment">/* Program header table entry count */</span></span><br><span class="line">  Elf64_Halfe_shentsize;<span class="comment">/* Section header table entry size */</span></span><br><span class="line">  Elf64_Halfe_shnum;  <span class="comment">/* Section header table entry count */</span></span><br><span class="line">  Elf64_Halfe_shstrndx;<span class="comment">/* Section header string table index */</span></span><br><span class="line">&#125; Elf64_Ehdr;</span><br></pre></td></tr></table></figure></p><p>其中 <strong><em>e_phnum</em></strong> 这个字段指出了这个 <strong><em>ELF可执行文件</em></strong> 含有多少个 <strong><em>program header table</em></strong>，我们可以通过 <strong><em>e_phoff</em></strong> 来定位到 <strong><em>program header table</em></strong> 在 <strong><em>ELF可执行文件</em></strong> 中的位置，并连续读出 <strong><em>e_phnum</em></strong> 个 <strong><em>program header table</em></strong>。</p><p><strong><em>Elf64_Phdr</em></strong> 就对应了上图中的段头部表，也就是 <strong><em>program header table</em></strong>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Wordp_type;<span class="comment">/* Segment type */</span></span><br><span class="line">  Elf64_Wordp_flags;<span class="comment">/* Segment flags */</span></span><br><span class="line">  Elf64_Offp_offset;<span class="comment">/* Segment file offset */</span></span><br><span class="line">  Elf64_Addrp_vaddr;<span class="comment">/* Segment virtual address */</span></span><br><span class="line">  Elf64_Addrp_paddr;<span class="comment">/* Segment physical address */</span></span><br><span class="line">  Elf64_Xwordp_filesz;<span class="comment">/* Segment size in file */</span></span><br><span class="line">  Elf64_Xwordp_memsz;<span class="comment">/* Segment size in memory */</span></span><br><span class="line">  Elf64_Xwordp_align;<span class="comment">/* Segment alignment */</span></span><br><span class="line">&#125; Elf64_Phdr;</span><br></pre></td></tr></table></figure><br>我们通过遍历 <strong><em>ELF可执行文件</em></strong> 中的 <strong><em>program header tables</em></strong>，筛选出 <strong><em>p_type</em></strong> 属性为 <strong><em>PT_LOAD</em></strong> 的 <strong><em>segment</em></strong> 装载到指定的内存中，我们的用户程序基本就完成了 <strong><em>load</em></strong>。</p><div class="note primary modern"><p>（这里我们以64位为例，32位也有对应的结构体）</p></div><p>当然还有一些小细节，比如说：</p><ul><li>为什么 <strong><em>p_memsz</em></strong> 通常比 <strong><em>p_filesz</em></strong> 大？</li><li>为什么要将<code>[VirtAddr + FileSiz, VirtAddr + MemSiz)</code>对应的物理区间清零？（<strong><em>tips</em></strong>： <strong><em>.bss段</em></strong> 的作用）</li><li>如果没有清零，全局变量/静态变量的初始值会是什么呢？</li></ul><p>如果你希望查阅更多与 <strong><em>ELF文件</em></strong> 相关的信息, 请参考:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man 5 elf</span><br></pre></td></tr></table></figure></p><p>我们知道 <strong><em>ELF文件</em></strong> 的开头有一个魔数，为了防止 <strong><em>loader</em></strong> 加载了一个非 <strong><em>ELF</em></strong> 格式的文件, 我们可以在 <strong><em>loader</em></strong> 中对魔数进行检查：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert(*(<span class="type">uint32_t</span> *)elf-&gt;e_ident == <span class="number">0xBadC0de</span>);</span><br></pre></td></tr></table></figure><br>请自行填写正确的魔数。</p><p>别看这个 <strong><em>assert</em></strong> 看起来蠢蠢的，等哪天不知道什么神奇的原因没有正确读取时，你会感谢自己的 <strong><em>“多此一举”</em></strong> 。</p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>在 <strong><em>GNU/Linux</em></strong> 中, 用户程序通过自陷指令来触发系统调用, <strong><em>Nanos-lite</em></strong> 也沿用这个约定. <strong><em>CTE</em></strong> 中的 <strong><em>yield()</em></strong> 也是通过自陷指令来实现。既然我们通过自陷指令来触发系统调用, 那么对用户程序来说, 用来向操作系统描述需求的最方便手段就是使用通用寄存器了，系统调用处理函数只需要从上下文中获取必要的信息, 就能知道用户程序发出的服务请求是什么了。</p><p><strong><em>Navy</em></strong> 已经为用户程序准备好了系统调用的接口了。<br><code>navy-apps/libs/libos/src/syscall.c</code>中定义的<code>_syscall_()</code>函数已经蕴含着上述过程：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">intptr_t</span> _syscall_(<span class="type">intptr_t</span> type, <span class="type">intptr_t</span> a0, <span class="type">intptr_t</span> a1, <span class="type">intptr_t</span> a2) &#123;</span><br><span class="line">  <span class="keyword">register</span> <span class="type">intptr_t</span> _gpr1 <span class="title function_">asm</span> <span class="params">(GPR1)</span> = type;</span><br><span class="line">  <span class="keyword">register</span> <span class="type">intptr_t</span> _gpr2 <span class="title function_">asm</span> <span class="params">(GPR2)</span> = a0;</span><br><span class="line">  <span class="keyword">register</span> <span class="type">intptr_t</span> _gpr3 <span class="title function_">asm</span> <span class="params">(GPR3)</span> = a1;</span><br><span class="line">  <span class="keyword">register</span> <span class="type">intptr_t</span> _gpr4 <span class="title function_">asm</span> <span class="params">(GPR4)</span> = a2;</span><br><span class="line">  <span class="keyword">register</span> <span class="type">intptr_t</span> ret <span class="title function_">asm</span> <span class="params">(GPRx)</span>;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span> <span class="params">(SYSCALL : <span class="string">&quot;=r&quot;</span> (ret) : <span class="string">&quot;r&quot;</span>(_gpr1), <span class="string">&quot;r&quot;</span>(_gpr2), <span class="string">&quot;r&quot;</span>(_gpr3), <span class="string">&quot;r&quot;</span>(_gpr4))</span>;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>理解上述函数你需要的文档：<a href="http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html"><strong><em>GCC-Inline-Assembly-HOWTO</em></strong></a></p><p><strong><em>CTE</em></strong> 会将这个自陷操作打包成一个系统调用事件 <strong><em>EVENT_SYSCALL</em></strong> , 并交由 <strong><em>Nanos-lite</em></strong> 继续处理。</p><p>添加一条系统调用类似于添加一条指令，其实没什么难度。<strong><em>Nanos-lite</em></strong> 收到系统调用事件之后, 就会调出系统调用处理函数 <strong><em>do_syscall()</em></strong> 进行处理。所以我们只需要根据系统调用号在 <strong><em>do_syscall()</em></strong> 添加相应的逻辑功能即可。</p><p>如果实现正确，你将看到：<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ图片20220929234734.png" alt=""></p><h2 id="操作系统之上的TRM"><a href="#操作系统之上的TRM" class="headerlink" title="操作系统之上的TRM"></a>操作系统之上的TRM</h2><p><strong><em>TRM</em></strong> 向我们展示了, 为了满足程序的基本计算能力, 需要有哪些条件:</p><ul><li>机器提供基本的运算指令</li><li>能输出字符</li><li>有堆区可以动态申请内存</li><li>可以结束运行<br>指令的运算我们已经在 <strong><em>PA2</em></strong> 实现了，程序的结束运行我们已经通过 <strong><em>SYS_exit</em></strong> 系统调用实现了。为了向用户程序提供输出字符和内存动态申请的功能, 我们需要实现更多的系统调用。</li></ul><h3 id="标准输出"><a href="#标准输出" class="headerlink" title="标准输出"></a>标准输出</h3><p>在 <strong><em>GNU/Linux</em></strong> 中, 输出是通过 <strong><em>SYS_write</em></strong> 系统调用来实现的。事实上, 我们平时使用的 <strong><em>printf()</em></strong> , <strong><em>cout</em></strong> 这些库函数和库类, 对字符串进行格式化之后, 最终也是通过系统调用进行输出。这些都是”系统调用封装成库函数”的例子。</p><p>因此我们只需要实现 <strong><em>SYS_write</em></strong> 系统调用就基本扫除了 <strong><em>printf()</em></strong> 的最大障碍了，至于 <strong><em>printf()</em></strong> 具体是如何实现的，<strong><em>Navy</em></strong> 中的<strong><em>Newlib库</em></strong> 已经为我们准备好了。</p><p>这里需要注意的是，操作系统的应用程序调用的 <strong><em>printf()</em></strong> 并不是我们编写的 <strong><em>klib</em></strong> 。<strong><em>klib</em></strong> 所处的抽象层位于 <strong><em>am</em></strong>，也就是驱动层，而操作系统在 <strong><em>am</em></strong> 之上再添加了一层抽象。因为操作系统并不打算把 <strong><em>am</em></strong> 暴露给我们的用户，所以操作系统的应用程序是无法直接调用 <strong><em>am</em></strong> 层的 <strong><em>API</em></strong> 的。</p><p>其实按理说，在这一步我们就能通过 <code>hello</code> 测试程序了。但如果你正确实现了 <strong><em>SYS_write</em></strong> 调用后会发现屏幕不断地在输出第一个字符<code>H</code>，这很难说是通过了。当你去阅读 <strong><em>Newlib库</em></strong> 中 <strong><em>printf()</em></strong> 的源码会发现，这是因为我们没有实现堆区分配导致的问题，也就是我们的下一个任务。很难说这是实验安排的疏忽，还是故意的呢？(笑)</p><h3 id="堆区管理"><a href="#堆区管理" class="headerlink" title="堆区管理"></a>堆区管理</h3><p>堆区的使用情况是由 <strong><em>libc</em></strong> 来进行管理的, 但堆区的大小却需要通过系统调用向操作系统提出更改。这是因为, 堆区的本质是一片内存区域, 当需要调整堆区大小的时候, 实际上是在调整用户程序可用的内存区域。如果一个恶意程序不经过操作系统就可以随意更改其他程序的内存区域，那就可以直接开香槟了（bushi）。</p><p>我们知道可执行文件里面有代码段和数据段, 链接的时候 <strong><em>ld</em></strong> 会默认添加一个名为 <strong><em>_end</em></strong> 的符号, 来指示程序的数据段结束的位置。用户程序开始运行的时候, <strong><em>program break</em></strong> 会位于 <strong><em>_end</em></strong> 所指示的位置, 意味着此时堆区的大小为0。</p><p>其实这部分的逻辑没有什么困难，核心思想就是维护 <strong><em>program break</em></strong> 的值即可。但是 <strong><em>program break</em></strong> 的初值 <strong><em>_end</em></strong> 我们该如何获取呢？这就是唯一的难点了。但是这个问题的答案其实也非常简单，前面已经说了 <strong><em>ld</em></strong> 的时候我们会添加 <strong><em>_end</em></strong> 的符号，那么我们只需要 <code>extern char _end</code> 即可，在链接阶段会自动取得该符号的定义。</p><p>当然了，你也可以通过 <code>man 3 end</code> 来查询如何使用 <code>_end</code> 符号。你会发现跟我说的其实是一样的。</p><p>如果你正确实现了上述两个系统调用，那么此时你应该能通过 <code>hello</code> 测试程序了：<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ图片20221002000222.png" alt=""></p><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="简易文件系统"><a href="#简易文件系统" class="headerlink" title="简易文件系统"></a>简易文件系统</h2><p>文件的本质就是字节序列, 另外还由一些额外的属性构成。在这里, 我们先讨论普通意义上的文件。那些额外的属性就维护了文件到 <code>ramdisk</code> 存储位置的映射,为了管理这些映射, 同时向上层提供文件操作的接口, 我们需要在 <code>Nanos-lite</code> 中实现一个文件系统。</p><p>我们对文件系统的需求并不是那么复杂, 因此我们可以定义一个简易文件系统 <code>sfs(Simple File System)</code>：</p><ul><li>每个文件的大小是固定的</li><li>写文件时不允许超过原有文件的大小</li><li>文件的数量是固定的, 不能创建新文件</li><li>没有目录</li></ul><p>我们约定文件从ramdisk的最开始一个挨着一个地存放：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">+-------------+---------+----------+-----------+--</span><br><span class="line">|    file0    |  file1  |  ......  |   filen   |</span><br><span class="line">+-------------+---------+----------+-----------+--</span><br><span class="line"> \           / \       /            \         /</span><br><span class="line">  +  size0  +   +size1+              + sizen +</span><br></pre></td></tr></table></figure></p><p>为了记录ramdisk中各个文件的名字和大小, 我们还需要一张”文件记录表”。</p><p>“文件记录表”其实是一个数组, 数组的每个元素都是一个结构体:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> *name;         <span class="comment">// 文件名</span></span><br><span class="line">  <span class="type">size_t</span> size;        <span class="comment">// 文件大小</span></span><br><span class="line">  <span class="type">size_t</span> disk_offset;  <span class="comment">// 文件在ramdisk中的偏移</span></span><br><span class="line">&#125; Finfo;</span><br></pre></td></tr></table></figure></p><p>由于 <code>sfs</code> 在设定上是没有目录的，所以目录分隔符也被当作了文件名的一部分，例如 <code>/bin/hello</code> 是一个完整的文件名。在文件数量不多的情况下，这种实现既 <strong><em>trivial</em></strong> 又 <strong><em>effective</em></strong> 。</p><p>下面主要讲解一下文件操作函数实现需要注意的坑了。 <strong><em>open()</em></strong> 和 <strong><em>close()</em></strong> 没什么好说的，重点是 <strong><em>read()</em></strong> 和 <strong><em>write()</em></strong> 。</p><p>在实现 <strong><em>read()</em></strong> 函数功能之前我们很有必要 <code>man 2 read</code> 一下：<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ图片20221006230048.png" alt=""><br>这意味着我们要注意文件描述符当前的 <strong><em>offset</em></strong> ，如果用户要求读取的长度超出了文件的大小，我们要及时做好控制，否则就可能读到奇怪的地方，从而产生莫名其妙的 <strong><em>bug</em></strong> (泪目)。</p><p>同理对 <strong><em>write()</em></strong> 也是一样的，重点是 <strong><em>读手册！读手册！读手册！</em></strong> 重要的事情说三遍。</p><p>这部分成功完成后，你应该能看到 <code>PASS!!!</code> 的信息：<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ图片20221006231125.png" alt=""></p><h2 id="一切皆文件"><a href="#一切皆文件" class="headerlink" title="一切皆文件"></a>一切皆文件</h2><p>所谓一切皆文件，实际上就是把各种五花八门的字节流都看成文件。比如说 <strong><em>设备</em></strong> 和 <strong><em>socket</em></strong> 本身就可以看成是一种字节流，那么自然而然地我们可以把他们抽象成文件。这么做的好处是我们可以提供统一的接口，去操纵计算机上的一切事物，而不必因为将来加入了新的设备而增加一个新的系统调用。</p><p><strong><em>Unix</em></strong> 就是这样做的, 因此有 <code>&quot;一切皆文件&quot;(Everything is a file)</code> 的说法。为了向用户程序提供统一的抽象, <strong><em>Nanos-lite</em></strong> 也尝试将 <strong><em>IOE</em></strong> 抽象成文件。</p><h3 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h3><p>为了实现一切皆文件的思想，我们不仅需要对普通文件进行读写, 还需要支持各种”特殊文件”的操作。</p><p>这组扩展语义之后的 <strong><em>API</em></strong> 有一个酷炫的名字, 叫 <code>VFS(虚拟文件系统)</code> 。</p><p>在 <strong><em>Nanos-lite</em></strong> 中, 实现 <strong><em>VFS</em></strong> 的关键就是 <strong><em>Finfo结构体</em></strong> 中的两个读写函数指针:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">char</span> *name;         <span class="comment">// 文件名</span></span><br><span class="line">  <span class="type">size_t</span> size;        <span class="comment">// 文件大小</span></span><br><span class="line">  <span class="type">size_t</span> disk_offset;  <span class="comment">// 文件在ramdisk中的偏移</span></span><br><span class="line">  ReadFn read;        <span class="comment">// 读函数指针</span></span><br><span class="line">  WriteFn write;      <span class="comment">// 写函数指针</span></span><br><span class="line">&#125; Finfo;</span><br></pre></td></tr></table></figure><br>只有特殊文件会被设置这两个读写函数指针，因此反过来说如果这两个读写函数指针为 <code>NULL</code> ，则说明该文件是普通文件。这样 <strong><em>VFS</em></strong> 的抽象就完成了。</p><h3 id="操作系统之上的IOE"><a href="#操作系统之上的IOE" class="headerlink" title="操作系统之上的IOE"></a>操作系统之上的IOE</h3><p>有了 <strong><em>VFS</em></strong> , 要把 <strong><em>IOE</em></strong> 抽象成文件就非常简单了。</p><p>串口输出没什么好讲的，这里先讲一下时钟这个输入设备。由于时钟比较特殊，大部分的 <strong><em>OS</em></strong> 并没有把它抽象成文件，而是提供了一个特殊的系统调用。我们在 <strong><em>Nanos-lite</em></strong> 里也是这么做的。</p><p>其实我们之前在 <strong><em>am</em></strong> 层已经做了准备工作了，<strong><em>Nanos-lite</em></strong> 作为一个 <strong><em>am</em></strong> 应用程序，能够直接调用 <strong><em>am</em></strong> 的 <strong><em>api</em></strong>。所以我们可以直接在实现中使用 <code>io_read(AM_TIMER_UPTIME)</code> 就能获取到系统的时间了。</p><p>时钟系统调用实现成功后可以看到：<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ图片20221008000127.png" alt=""></p><p>关于时钟还有另外一个需要注意的点是我们后续需要实现的 <strong><em>NDL</em></strong> 函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以毫秒为单位返回系统时间</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">NDL_GetTicks</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><br>这里是以毫秒为单位返回的，和我们之前默认的使用单位是不同的，要注意转换。</p><p>下一个输入设备是键盘。按键的信息对于系统来说可以抽象为一个事件，而事件很适合用文本来描述。由于文本本身就是一种字节流，所以事件抽象成文件十分简单，而且可读性很好。因此我们把上述事件抽象成一个特殊文件 <code>/dev/events</code> 加入到 <code>file_table[]</code> 中，该特殊文件需要支持读操作。和时钟类似，我们可以借助 <strong><em>IOE</em></strong> 的 <strong><em>api</em></strong> 来获取按键信息，打包成事件再供用户读取。</p><p>实现效果如下：<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ图片20221008001531.png" alt=""><br>在进行键盘测试的时候注意要在弹出的窗口中输入按键才是有效的，否则你很有可能怀疑是自己没有正确实现按键功能 :-(</p><p>讲义中还提出了一个非常值得思考的问题，当我们对这些即时性要求非常高的特殊文件操作的时候，我们应该是选用 <strong><em>fopen()</em></strong> 还是 <strong><em>open()</em></strong> 呢？这两者的区别是啥呢？其实他们之间的差别就是 <strong><em>fopen()</em></strong> 内置了一个缓冲区，这个缓冲区会对我们的读取造成什么影响呢？你稍微想一下应该就能明白了。</p><p>最后是 <strong><em>VGA</em></strong> , 程序为了更新屏幕, 只需要将像素信息写入VGA的显存即可。而我们要做的，就是把显存抽象成文件。</p><p>显存本身也是一段存储空间, 它以行优先的方式存储了将要在屏幕上显示的像素。这一点实在是太重要了，虽然前面实现 <strong><em>VGA</em></strong> 时已经强调过了，但这里还是不得不再提一遍。</p><p>这里还引入了一个新的概念，<strong><em>“画布”</em></strong> 。我们必须认识到，画布和屏幕是两个东西。我们绘制画面只能在我们的画布范围内绘制。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开一张(*w) X (*h)的画布</span></span><br><span class="line"><span class="comment">// 如果*w和*h均为0, 则将系统全屏幕作为画布, 并将*w和*h分别设为系统屏幕的大小</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">NDL_OpenCanvas</span><span class="params">(<span class="type">int</span> *w, <span class="type">int</span> *h)</span>;</span><br></pre></td></tr></table></figure><br>我们可以利用这个 <strong><em>api</em></strong> 来打开一张画布，注意这里有特殊的默认状况，要特殊处理一下。</p><p>实验中还要求我们实现居中的 <strong><em>logo</em></strong> ，这个其实只需要简单的计算一下起始坐标的 <strong><em>offset</em></strong> 就行了，也就是 <strong><em>pixels</em></strong> 的左上角那个点到底是什么就行。</p><p>实现成功后，你将看到居中的 <strong><em>logo</em></strong>：<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ图片20221009000546.png" alt=""></p><h1 id="精彩纷呈的应用程序"><a href="#精彩纷呈的应用程序" class="headerlink" title="精彩纷呈的应用程序"></a>精彩纷呈的应用程序</h1><p>TODO</p>]]></content>
      
      
      <categories>
          
          <category> PA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PA </tag>
            
            <tag> OS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PA2实验笔记</title>
      <link href="/archives/81c5e64f.html"/>
      <url>/archives/81c5e64f.html</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>PA是NJU ICS的课程实验，作为一个非科班的学生，要完成这个实验属实不易，但是在这个过程中我收获到的知识和经验无疑是我求学路上无比宝贵的财富。为了记录下这宝贵的经历，故写此博客记录下我的苦恼与感悟。在这篇博客里我会简单叙述我的思路和踩过的坑。<strong><em>另外特此声明，如果您本身需要独自完成PA实验，为了学术诚信，请自行完成后再参考本博客，今日偷的懒，在未来会加倍偿还！</em></strong></p><h1 id="不停计算的机器"><a href="#不停计算的机器" class="headerlink" title="不停计算的机器"></a>不停计算的机器</h1><p>在PA1中, 我们已经见识到最简单的计算机TRM的工作方式:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  从PC指示的存储器位置取出指令;</span><br><span class="line">  执行指令;</span><br><span class="line">  更新PC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对于大部分指令来说, 执行它们都可以抽象成 <strong><em>取指-译码-执行</em></strong> 的指令周期。对于TRM来说，只要内存无限，这个循环就可以一直进行下去，是真正意义上的不停计算的机器。</p><h1 id="RTFSC-友好地阅读源码"><a href="#RTFSC-友好地阅读源码" class="headerlink" title="RTFSC(友好地阅读源码)"></a>RTFSC(友好地阅读源码)</h1><p>我们在PA1中提到:</p><blockquote><p>我们可以看到 <strong><em>cpu_exec()</em></strong> 模拟了CPU的工作方式: 不断执行指令.  <strong><em>fetch_decode_exec_updatepc()</em></strong> 函数  <strong><em>(在nemu/src/cpu/cpu-exec.c中定义)</em></strong> 让CPU执行当前PC指向的一条指令, 然后更新PC.</p></blockquote><p>因此我们只需要弄懂 <strong><em>fetch_decode_exec_updatepc()</em></strong> 的工作原理，就可以很好地完成 <strong><em>取指-译码-执行</em></strong> 的工作了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">fetch_decode_exec_updatepc</span><span class="params">(Decode *s)</span> &#123;</span><br><span class="line">  fetch_decode(s, cpu.pc); <span class="comment">// 取出指令并且译码</span></span><br><span class="line">  s-&gt;EHelper(s);           <span class="comment">// 执行</span></span><br><span class="line">  cpu.pc = s-&gt;dnpc;        <span class="comment">// 更新PC</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="取指-instruction-fetch-IF"><a href="#取指-instruction-fetch-IF" class="headerlink" title="取指(instruction fetch, IF)"></a>取指(instruction fetch, IF)</h2><p>如果你跳转到 <strong><em>fetch_decode(s, cpu.pc)</em></strong> 的定义里查看，就会发现这个函数的工作就是把当前的 <strong><em>PC</em></strong> 保存到 <strong><em>s</em></strong> 的成员 <strong><em>pc</em></strong> 和 <strong><em>snpc</em></strong> 中, 其中 <strong><em>s-&gt;pc</em></strong> 就是当前指令的 <strong><em>PC</em></strong>, 而 <strong><em>s-&gt;snpc</em></strong> 则是下一条指令的 <strong><em>PC</em></strong>, 这里的 <strong><em>snpc</em></strong> 是 <strong><em>“static next PC”</em></strong> 的意思。</p><p>而这个函数中的重头戏其实是 <strong><em>isa_fetch_decode()</em></strong> 这个函数调用。<strong><em>isa_fetch_decode()</em></strong> 做的第一件事就是从内存中取指令，这项工作具体由 <strong><em>instr_fetch()</em></strong> 函数来完成。<strong><em>instr_fetch()</em></strong> 会根据你传入的 <strong><em>pc</em></strong> 和期望的字节长度，经过一层转发最终调用 <strong><em>paddr_read()</em></strong> 函数来访问物理内存中的内容。因此取值操作就是一个简单的内存访问而已。并且 <strong><em>instr_fetch()</em></strong> 将返回一个 <strong><em>uint32_t</em></strong> 类型的数据，并将其赋值给 <strong><em>s</em></strong> 指向的 <strong><em>Decode</em></strong> 结构体，这样 <strong><em>Decode </em>s*</strong> 指向的结构体就持有了该条指令的全部信息了，接下来的工作就是解析出该指令的信息。</p><p>调用 <strong><em>instr_fetch()</em></strong> 的时候传入了 <strong><em>s-&gt;snpc</em></strong> 的地址, 因此 <strong><em>instr_fetch()</em></strong> 最后还会根据 <strong><em>len</em></strong> 来更新 <strong><em>s-&gt;snpc</em></strong> , 从而让 <strong><em>s-&gt;snpc</em></strong> 指向下一条指令。</p><p><strong><em>总结下来，取指工作完成了两件事情：</em></strong></p><ul><li><strong><em>s</em></strong> 指向的 <strong><em>Decode</em></strong> 结构体获得当前 <strong><em>pc</em></strong> 所指向的指令</li><li>更新 <strong><em>s-&gt;snpc</em></strong>， 让 <strong><em>s-&gt;snpc</em></strong> 指向下一条指令。</li></ul><p><strong><em>另外很有必要的一件事是清楚 </em></strong>Decode<strong><em> 结构体的内容，具体地：</em></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Decode</span> &#123;</span></span><br><span class="line">  <span class="type">vaddr_t</span> pc;   <span class="comment">// 当前指令内存的位置</span></span><br><span class="line">  <span class="type">vaddr_t</span> snpc; <span class="comment">// static next pc</span></span><br><span class="line">  <span class="type">vaddr_t</span> dnpc; <span class="comment">// dynamic next pc</span></span><br><span class="line">  <span class="type">void</span> (*EHelper)(<span class="keyword">struct</span> Decode *); <span class="comment">// 执行指令的函数 </span></span><br><span class="line">  Operand dest, src1, src2;         <span class="comment">// 目标和源1 源2</span></span><br><span class="line">  ISADecodeInfo isa;                <span class="comment">// 实际二进制指令</span></span><br><span class="line">  IFDEF(CONFIG_ITRACE, <span class="type">char</span> logbuf[<span class="number">128</span>]);  <span class="comment">// 此项可暂时忽略</span></span><br><span class="line">&#125; Decode;</span><br></pre></td></tr></table></figure></p><h2 id="译码-instruction-decode-ID"><a href="#译码-instruction-decode-ID" class="headerlink" title="译码(instruction decode, ID)"></a>译码(instruction decode, ID)</h2><p>译码的目的是得到指令的操作和操作对象, 这主要是通过查看指令的 <strong><em>opcode（操作码）</em></strong> 来决定的。当然不同的 <strong><em>ISA</em></strong> 的 <strong><em>opcode</em></strong> 的位置和组织方式不同，我们需要通过相应的手册来获取这些信息。而我所选择的 <strong><em>ISA</em></strong> 是 <strong><em>RISCV-32</em></strong> , 这是一款年轻开源并且极富潜力的 <strong><em>ISA</em></strong>, 他的所有指令都是32位定长的，这对于我们的译码来说将会提供很大的帮助。</p><p>NEMU使用一种抽象层次更高的译码方式: <strong><em>模式匹配</em></strong>, 可以通过一个模式字符串来指定指令中的 <strong><em>opcode</em></strong>。以我所选的 <strong><em>RISCV-32</em></strong> 举例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def_INSTR_IDTAB(<span class="string">&quot;??????? ????? ????? ??? ????? 01101 11&quot;</span>, U     , lui);</span><br></pre></td></tr></table></figure><br>模式字符串中只允许出现4种字符:</p><ul><li>0表示相应的位只能匹配0</li><li>1表示相应的位只能匹配1</li><li>?表示相应的位可以匹配0或1</li><li>(空格)是分隔符, 只用于提升模式字符串的可读性, 不参与匹配</li></ul><p>其中 <strong><em>def_INSTR_IDTAB</em></strong> 是一个宏，对其进行展开后可以得到：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="type">uint32_t</span> key, mask, shift;</span><br><span class="line">  pattern_decode(<span class="string">&quot;??????? ????? ????? ??? ????? 01101 11&quot;</span>, <span class="number">37</span>, &amp;key, &amp;mask, &amp;shift);</span><br><span class="line">  <span class="keyword">if</span> (((s-&gt;isa.instr.val &gt;&gt; shift) &amp; mask) == key) &#123;</span><br><span class="line">    decode_U(s, <span class="number">0</span>);       <span class="comment">// 译码辅助函数，其中第二个参数width是专门为x86这种不定长指令准备的，</span></span><br><span class="line">                          <span class="comment">// 而我选择的RISCV-32其实并不需要第二个参数，所以直接默认都是为0</span></span><br><span class="line">    <span class="keyword">return</span> table_lui(s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br></pre></td></tr></table></figure><br>对于 <strong><em>pattern_decode</em></strong> 具体如何工作你可以跳转到他的定义去了解，但在这里其实不是重点，重点是经过一系列转换后我们的一段32位的定长指令可以精确匹配到 <strong><em>RISCV-32</em></strong> 的的六种基本指令格式： <strong><em>R、I、S、B、U、J。</em></strong> </p><p>此时指令满足上述宏展开的if语句, 表示匹配到 <strong><em>lui指令</em></strong> 的编码, 因此将会进行进一步的译码操作。</p><p>刚才我们只知道了指令的具体操作(比如 <strong><em>lui指令</em></strong> 是读入一个立即数到寄存器的高位), 但我们还是不知道操作对象(比如立即数是多少, 读入到哪个寄存器)。为了解决这个问题, 代码需要进行进一步的译码工作, 这是通过调用相应的 <strong><em>译码辅助函数(decode helper function)</em></strong> 来完成的。</p><p>译码辅助函数统一通过宏 <strong><em>def_DHelper(在nemu/include/cpu/decode.h中定义)</em></strong> 来定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> def_DHelper(name) void concat(decode_, name) (Decode *s)</span></span><br></pre></td></tr></table></figure><br>请注意，这其实只是为了方便生成多个函数签名，其实是没有函数体的，因为每种指令的的操作对象有可能是立即数也可能是寄存器，关于如何定义函数体是要根据每种指令的类型来定制的。</p><p>每个 <strong><em>译码辅助函数</em></strong> 负责进行一种类型的操作数译码, 把指令中的操作数信息分别记录在译码信息 <strong><em>s</em></strong> 的 <strong><em>dest成员</em></strong> , <strong><em>src1成员</em></strong> 和 <strong><em>src2成员</em></strong> 中, 它们分别代表目的操作数和两个源操作数。</p><p>我们会发现, 类似寄存器和立即数这些操作数, 其实是非常常见的操作数类型. 为了进一步实现 <strong><em>操作数译码</em></strong> 和 <strong><em>指令译码</em></strong> 的解耦, 框架代码对这些操作数的译码进行了抽象封装, 指令译码过程由若干 <strong><em>译码操作数辅助函数(decode operand helper function)</em></strong> 组成. 译码操作数辅助函数统一通过宏 <strong><em>def_DopHelper</em></strong> 来定义。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> def_DopHelper(name) \</span></span><br><span class="line"><span class="meta">  void concat(decode_op_, name) (Decode *s, Operand *op, word_t val, bool flag)</span></span><br></pre></td></tr></table></figure><br><strong><em>DopHelper</em></strong> 带有一个flag参数, 不同的 <strong><em>DopHelper</em></strong> 可以用它来进行不同的处理. 例如寄存器的 <strong><em>DopHelper</em></strong> 可以通过flag来指示是否写入:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="title function_">def_DopHelper</span><span class="params">(r)</span> &#123;</span><br><span class="line">  <span class="type">bool</span> is_write = flag;</span><br><span class="line">  <span class="type">static</span> <span class="type">word_t</span> zero_null = <span class="number">0</span>;</span><br><span class="line">  op-&gt;preg = (is_write &amp;&amp; val == <span class="number">0</span>) ? &amp;zero_null : &amp;gpr(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在 <strong><em>mips</em></strong> 和 <strong><em>riscv</em></strong> 中, 0号寄存器的值恒为0, 因此往0号寄存器的写入操作都会被硬件忽略. 为了实现这个功能, 上述代码会在译码的时候检查指令是否尝试往0号寄存器进行写入, 若是, 则把写入的目的修改成一个 <strong><em>“黑洞变量”</em></strong> , 这个变量不会被其它代码读取, 从而实现”往0号寄存器的写入操作都会被硬件忽略”的效果。</p><p>有了这些 <strong><em>译码操作数辅助函数（def_DopHelper）</em></strong> , 我们就可以用它们来编写 <strong><em>译码辅助函数（def_DHelper）</em></strong> 了, 例如 <strong><em>riscv</em></strong> 中 <strong><em>I-型指令</em></strong> 的译码过程可以通过如下代码实现:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="title function_">def_DHelper</span><span class="params">(I)</span> &#123;</span><br><span class="line">  decode_op_r(s, id_src1, s-&gt;isa.instr.i.rs1, <span class="literal">false</span>);       <span class="comment">// def_DopHelper(r)</span></span><br><span class="line">  decode_op_i(s, id_src2, s-&gt;isa.instr.i.simm11_0, <span class="literal">false</span>);  <span class="comment">// def_DopHelper(i)</span></span><br><span class="line">  decode_op_r(s, id_dest, s-&gt;isa.instr.i.rd, <span class="literal">true</span>);         <span class="comment">// def_DopHelper(r)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>回到 <strong><em>def_INSTR_IDTAB</em></strong> 的宏展开结果, 对于 <strong><em>lui指令</em></strong>, 在 <strong><em>译码辅助函数decode_U()</em></strong> 执行结束后, 代码将会执行 <strong><em>table_lui()</em></strong> 。<strong><em>table_lui()</em></strong> 的定义方式比较特殊, 我们在这里先给出部分宏展开后的定义:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def_THelper(lui) &#123;</span><br><span class="line">  <span class="keyword">return</span> EXEC_ID_lui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>宏 <strong><em>def_THelper(在nemu/include/cpu/decode.h中定义)</em></strong> 用于统一定义 <strong><em>“表格辅助函数”(table helper function)</em></strong> 。 <strong><em>table_lui()</em></strong> 做的事情很简单, 它直接返回一个标识lui指令的唯一ID. 这个ID会作为译码结果的返回值, 在 <strong><em>fetch_decode()</em></strong> 中索引 <strong><em>g_exec_table数组</em></strong> 。</p><p><strong><em>g_exec_table数组</em></strong> 其实就是一个存放指令执行函数指针的数组，通过正确的ID能映射到正确的指令执行函数，并将其赋值给 <strong><em>s</em></strong> 指向的 <strong><em>Decode</em></strong> 结构体。</p><p><strong><em>事实上, NEMU把译码时的如下情况都看作是查表过程：</em></strong></p><ul><li>在 <strong><em>isa_fetch_decode()</em></strong> 中查 <strong><em>主表(main decode table)</em></strong> ，其实就是 <strong><em>int idx = table_main(s);</em></strong> 这句代码</li><li>在译码过程中分别匹配指令中的每一个域</li><li>译码出最终的指令时认为是一种特殊的查表操作, 直接返回标识该指令的唯一ID</li><li>如果所有模式匹配规则都无法成功匹配, 代码将会返回一个标识非法指令的ID<br><strong><em>踩坑点以及感悟！！！！：</em></strong></li><li>忽视了指令中 <strong><em>funct3</em></strong> 以及 <strong><em>funct7</em></strong> 的重要性，由于 <strong><em>RISCV-32</em></strong> 指令的高度统一性，如果你没有把手册中的所有有效信息在模式匹配的时候完全匹配上，就有可能会出现 <strong><em>指鹿为马</em></strong> 的坑爹情况。例如 <strong><em>ori</em></strong> 和 <strong><em>andi</em></strong> 这两个指令，他们的 <strong><em>opcode</em></strong> 完全一样，唯一的差别是前者的 <strong><em>funct3</em></strong> 为 <strong><em>110</em></strong>，而后者的为 <strong><em>111</em></strong>，仅一位之差，就有可能是完全不同的语义，请务必特别小心！</li><li>辅助函数太多，宏转发看的头晕，呆坐半天都无法理解是如何完成一条指令的译码的。原讲义中关于各种辅助函数的宏命名实在太过相像且没有突出显示，所以在我的笔记中我着重突出了辅助函数的名字，方便各位查阅。关于宏转发看的头晕的问题，最好的解决办法是画一张连线图，毕竟人脑无法模拟太复杂的状态机，把转发的过程画下来将更有助于你理解这整个过程。</li><li>这里我画了一张 <strong><em>lui指令</em></strong> 的译码流程图，供大家参考：<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/译码过程图.png" alt=""></li><li>经过这些转发我们得到了什么？答案是我们得到了该指令所需要的 <strong><em>目的操作数和两个源操作数(部分是只有一个源操作数)</em></strong>，并将信息存储在了 <strong><em>s</em></strong> 所指向的 <strong><em>Decode</em></strong> 结构体中，以及返回了 <strong><em>指令的唯一ID</em></strong>，<strong><em>指令的唯一ID</em></strong> 将为我们索引 <strong><em>g_exec_table数组</em></strong> 并得到该指令唯一对应的指令执行函数，在这为我们后续执行指令的操作提供了必要的原材料。</li></ul><h2 id="执行-execute-EX"><a href="#执行-execute-EX" class="headerlink" title="执行(execute, EX)"></a>执行(execute, EX)</h2><p>译码过程结束之后, 接下来会返回到 <strong><em>fetch_decode()</em></strong> 中, 并通过返回的ID来从 <strong><em>g_exec_table数组</em></strong> 中选择相应的 <strong><em>执行辅助函数(execution helper function)</em></strong> , 然后记录到 <strong><em>s-&gt;EHelper</em></strong> 中。</p><p><strong><em>执行辅助函数</em></strong> 统一通过宏 <strong><em>def_EHelper</em></strong> (在nemu/include/cpu/exec.h中定义)来定义:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> def_EHelper(name) static inline void concat(exec_, name) (Decode *s)</span></span><br></pre></td></tr></table></figure><br>它们的名字是指令操作本身. <strong><em>执行辅助函数</em></strong> 通过 <strong><em>RTL指令</em></strong> 来描述指令真正的执行功能 (<strong><em>RTL指令</em></strong> 将在下文介绍) 。</p><p>每个 <strong><em>执行辅助函数</em></strong> 都需要有一个标识该指令的 <strong><em>ID</em></strong> 以及一个 <strong><em>表格辅助函数</em></strong> 与之相对应, 这一点是通过一系列宏定义来实现的。</p><p>表示指令列表的宏 <strong><em>INSTR_LIST</em></strong> , 它定义了NEMU支持的所有指令。具体的宏展开行为，亲自行 <strong><em>RTSFC</em></strong> 。</p><h2 id="更新PC"><a href="#更新PC" class="headerlink" title="更新PC"></a>更新PC</h2><p>更新PC的操作非常简单, 只需要把 <strong><em>s-&gt;dnpc</em></strong> 赋值给 <strong><em>cpu.pc</em></strong> 即可。我们之前提到了 <strong><em>snpc</em></strong> 和 <strong><em>dnpc</em></strong> , 现在来说明一下它们的区别。<br><div class="note primary modern"><p><strong><em>静态指令和动态指令</em></strong><br>在程序分析领域中, 静态指令是指程序代码中的指令, 动态指令是指程序运行过程中的指令。例如对于以下指令序列：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">100: jmp 102</span><br><span class="line">101: add</span><br><span class="line">102: xor</span><br></pre></td></tr></table></figure><br>jmp指令的下一条静态指令是add指令, 而下一条动态指令则是xor指令。</p></div></p><p>有了静态指令和动态指令这两个概念之后, 我们就可以说明 <strong><em>snpc</em></strong> 和 <strong><em>dnpc</em></strong> 的区别了: <strong><em>snpc</em></strong> 是指代码中的下一条指令, 而 <strong><em>dnpc</em></strong> 是指程序运行过程中的下一条指令。<br>显然, 我们应该使用 <strong><em>s-&gt;dnpc</em></strong> 来更新 <strong><em>PC</em></strong> , 并且在执行辅助函数中正确维护 <strong><em>s-&gt;dnpc</em></strong> 。</p><h1 id="用RTL表示指令行为"><a href="#用RTL表示指令行为" class="headerlink" title="用RTL表示指令行为"></a>用RTL表示指令行为</h1><p>在 <strong><em>NEMU</em></strong> 中, 我们使用 <strong><em>RTL(寄存器传输语言)</em></strong> 来描述我们指令的具体行为。其实你可以把 <strong><em>RTL</em></strong> 看作微指令，每一条具体指令的行为都是由微指令拼凑而成的。</p><p>下面我们对 <strong><em>NEMU</em></strong> 中使用的 <strong><em>RTL</em></strong> 进行一些说明, 首先是 <strong><em>RTL寄存器</em></strong> 的定义. 在NEMU中, <strong><em>RTL寄存器</em></strong> 统一使用 <strong><em>rtlreg_t</em></strong> 来定义。而 <strong><em>rtlreg_t</em></strong> 其实只是一个 <strong><em>word_t</em></strong> 类型。</p><p>在 <strong><em>NEMU</em></strong> 中, <strong><em>RTL寄存器</em></strong> 只有以下这些：</p><ul><li>不同 <strong><em>ISA</em></strong> 的通用寄存器(在nemu/src/isa/$ISA/include/isa-def.h中定义)</li><li>临时寄存器 <strong><em>s0, s1, s2和 t0</em></strong> (在nemu/include/rtl/rtl.h中定义)</li><li>零寄存器 <strong><em>rz</em></strong> (在nemu/include/rtl/rtl.h中定义), 它的值总是0</li></ul><p>有了 <strong><em>RTL寄存器</em></strong> , 我们就可以定义 <strong><em>RTL指令</em></strong> 对它们进行的操作了. 在 <strong><em>NEMU</em></strong> 中, <strong><em>RTL指令</em></strong> 有两种。</p><ul><li>一种是 <strong><em>RTL基本指令</em></strong> (在nemu/src/engine/interpreter/rtl-basic.h中定义), 它们的特点是不需要使用临时寄存器, 可以看做是CPU执行过程中最基本的操作. 不同的 <strong><em>ISA</em></strong> 都可以使用 <strong><em>RTL基本指令</em></strong>, 因此它们属于 <strong><em>ISA无关</em></strong> 的代码。</li><li>第二种是 <strong><em>RTL伪指令</em></strong>, 它们是通过 <strong><em>RTL基本指令</em></strong> 或者已经实现的 <strong><em>RTL伪指令</em></strong> 来实现的。</li></ul><p>其中大部分 <strong><em>RTL伪指令</em></strong> 还没有实现, 必要的时候你需要实现它们。</p><h1 id="实现新指令"><a href="#实现新指令" class="headerlink" title="实现新指令"></a>实现新指令</h1><p>对译码, 执行和操作数宽度的解耦实现以及 <strong><em>RTL</em></strong> 的引入, 对在 <strong><em>NEMU</em></strong> 中实现客户指令提供了很大的便利, 为了实现一条新指令, 你只需要：</p><ul><li>添加正确的模式匹配规则 <strong><em>（nemu/src/isa/$ISA/instr/decode.c）</em></strong></li><li>用 <strong><em>RTL</em></strong> 实现正确的 <strong><em>执行辅助函数</em></strong></li><li>把指令添加到 <strong><em>（nemu/src/isa/$ISA/include/isa-all-instr.h  INSTR_LIST）</em></strong> 中</li><li>必要时在中添加相应的头文件 <strong><em>（nemu/src/isa/$ISA/include/isa-exec.h）</em></strong></li></ul><h2 id="关于指令的实现"><a href="#关于指令的实现" class="headerlink" title="关于指令的实现"></a>关于指令的实现</h2><p>万事开头难，如果这是你第一次实现 <strong><em>RISCV-32</em></strong> 指令，想必会有许多困惑。比如这条指令的具体行为，这条指令属于什么类型，哪些是伪指令，哪些是基础指令等等这些问题，会像洪水一样向你怒涛袭来，而缓解恐惧的最佳方法就是阅读手册。当你阅读手册之后，你才能弄懂一切，你才能取回掌握一切的那种感觉，你会再一次坚信，<strong><em>计算机的世界里没有魔法</em></strong> 。掌握感和确定性，这是编程带给我最美妙的感觉。</p><p>我这里就讲解一条最简单的 <strong><em>li指令</em></strong> 的实现。首先看 <strong><em>RV32I</em></strong> 基础指令集中有没有 <strong><em>li指令</em></strong>：</p><p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ图片20220821230158.png" alt=""><br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ图片20220821230349.png" alt=""></p><p>我们仔细查阅了指令集表后，发现并没有所谓的 <strong><em>li指令</em></strong>。那么有没有可能是在别的基础指令集中呢？有这个可能，当你问出这个问题的时候，你已经按耐不住自己查阅手册了吧。这是一个很好的开始，请去仔细查阅后找到你想要的答案。</p><p>在这里我们给出答案，<strong><em>li指令</em></strong> 是一个伪指令，它只是基础指令的一种特殊情况而已。</p><p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ图片20220821231009.png" alt=""></p><p>它的行为也很简单，就是读取一个立即数到目的寄存器而已。并且官方也没有给出 <strong><em>li指令</em></strong> 的明确实现方式，不像其他伪指令一样，可以看到一般是有对应的基础指令的特殊情况的。这主要是因为 <strong><em>li指令</em></strong> 的实现太过灵活，官方就不打算全部列举出来了。</p><p>而我的实现也很简单，就是利用 <strong><em>addi指令</em></strong> 来实现 <strong><em>li指令</em></strong>。关于 <strong><em>addi指令</em></strong> 的具体行为，就交给你自己去阅读手册了，在这里我只提醒一点，关于 <strong><em>addi指令</em></strong> 的源操作数中的 <strong><em>imm立即数</em></strong> ，需要进行什么特殊处理吗？如果你忽略了这点，我可以肯定 <strong><em>bug</em></strong> 很快就会找上门来。</p><h1 id="程序-运行时环境与AM"><a href="#程序-运行时环境与AM" class="headerlink" title="程序, 运行时环境与AM"></a>程序, 运行时环境与AM</h1><p>一方面, 应用程序的运行都需要运行时环境的支持; 另一方面, 只进行纯粹计算任务的程序在 <strong><em>TRM</em></strong> 上就可以运行, 更复杂的应用程序对运行时环境必定还有其它的需求: 例如你之前玩的超级玛丽需要和用户进行交互, 至少需要运行时环境提供输入输出的支持. 要运行一个现代操作系统, 还要在此基础上加入更高级的功能。</p><p>如果我们把这些需求都收集起来, 将它们抽象成统一的API提供给程序, 这样我们就得到了一个可以支撑各种程序运行在各种架构上的库了! 具体地, 每个架构都按照它们的特性实现这组API; 应用程序只需要直接调用这组API即可, 无需关心自己将来运行在哪个架构上。由于这组统一抽象的API代表了程序运行对计算机的需求, 所以我们把这组API称为抽象计算机。</p><p><strong><em>AM(Abstract machine)</em></strong> 项目就是这样诞生的。作为一个向程序提供运行时环境的库, <strong><em>AM</em></strong> 根据程序的需求把库划分成以下模块：<br><div class="note primary modern"><p>AM = TRM + IOE + CTE + VME + MPE</p></div></p><ul><li><strong><em>TRM(Turing Machine)</em></strong> - 图灵机, 最简单的运行时环境, 为程序提供基本的计算能力</li><li><strong><em>IOE(I/O Extension)</em></strong> - 输入输出扩展, 为程序提供输出输入的能力</li><li><strong><em>CTE(Context Extension)</em></strong> - 上下文扩展, 为程序提供上下文管理的能力</li><li><strong><em>VME(Virtual Memory Extension)</em></strong> - 虚存扩展, 为程序提供虚存管理的能力</li><li><strong><em>MPE(Multi-Processor Extension)</em></strong> - 多处理器扩展, 为程序提供多处理器通信的能力 (MPE超出了ICS课程的范围, 在PA中不会涉及)</li></ul><div class="note blue modern"><p>(在NEMU中)实现硬件功能 -&gt; (在AM中)提供运行时环境 -&gt; (在APP层)运行程序<br>(在NEMU中)实现更强大的硬件功能 -&gt; (在AM中)提供更丰富的运行时环境 -&gt; (在APP层)运行更复杂的程序</p></div><h2 id="运行更多程序"><a href="#运行更多程序" class="headerlink" title="运行更多程序"></a>运行更多程序</h2><p>在这一部分其实就是要不断不断地实现更多的指令，来使我们的硬件的能力更加强大。如果你之前已经独立实现过指令了，那么这里对你其实已经不存在理解上的困难了，而更多的是工程上的问题了。</p><p>这里贴一下我的 <strong><em>cpu-tests</em></strong> 全通过的截图：<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ图片20220821233848.png" alt=""></p><p>在这里我再抛出几个问题，都是我认为的非常值得思考的：</p><ol><li><strong><em>cpu-tests</em></strong> 全通过代表指令已经没有 <strong><em>bug</em></strong> 了吗？</li><li>我不想在测试的时候一下就结束了，完全没有使用 <strong><em>sdb</em></strong> 的机会，请问有什么选项可以关闭批处理模式吗？<br>（提示：关键在于弄清楚 <strong><em>makefile</em></strong> 如何向 <strong><em>NEMU</em></strong> 传参）</li></ol><h2 id="重新认识计算机-计算机是个抽象层"><a href="#重新认识计算机-计算机是个抽象层" class="headerlink" title="重新认识计算机: 计算机是个抽象层"></a>重新认识计算机: 计算机是个抽象层</h2><p>大家在做实验的时候也可以多多思考: 我现在写的代码究竟位于哪一个抽象层? 代码的具体行为究竟是什么?</p><p>先来讨论在 <strong><em>TRM</em></strong> 上运行的程序, 我们对这些程序的需求进行分类, 来看看我们的计算机系统是如何支撑这些需求的：<br>| TRM | 计算 | 内存申请 | 结束运行 | 打印信息 |<br>| —- | —- | —- | —- | —- |<br>|运行环境|-|malloc()/free()|-|printf()|<br>|AM API|-|heap|halt()|putch()|<br>|ISA接口|指令|物理内存地址空间|nemu_trap指令|I/O方式|<br>|硬件模块|处理器|物理内存|Monitor|Monitor|<br>|电路实现|cpu_exec()|pmem[]|nemu_state    s|serial_io_handler()|</p><p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/pa-concept.png" alt=""></p><h1 id="基础设施-2"><a href="#基础设施-2" class="headerlink" title="基础设施(2)"></a>基础设施(2)</h1><p>这一部分主要是用来完善各种基础设施的，相信我，你值得为了这些基础设施付出精力，这将会为你后面诊断 <strong><em>bug</em></strong> 省下无数宝贵的时间。</p><p>因为 <strong><em>ftrace</em></strong> 到后面实现 <strong><em>loader</em></strong> 的时候还会有涉及，就暂且先搁置下来后面再一起讲。</p><p>这里我就主要讲我最看重的设施之一：<strong><em>difftest</em></strong></p><h2 id="Differential-Testing"><a href="#Differential-Testing" class="headerlink" title="Differential Testing"></a>Differential Testing</h2><p>在前面的部分中我们已经实现了很多指令了，并且已经顺利地通过了 <strong><em>cpu-tests</em></strong>。然而，我们就能完全放心了吗？我们的指令真的已经完全合乎手册的要求了吗？我看未必。<strong><em>bug</em></strong> 的种子或许已经埋下，只是在目前还没有发芽而已。随着我们测试的程序越来越复杂，汇编代码的行数也会暴增，如果我们的指令实现出现错误，其恶果或许将经过一段很长的调用链后才展露在我们面前。这对我们来找 <strong><em>bug</em></strong> 的难度来说可以说是噩梦级别的。</p><p>如果有一种方法能够表达指令的正确行为, 我们就可以基于这种方法来进行类似 <strong><em>assert()</em></strong> 的检查了。听起来很熟悉对不对，这其实就是我们高中就学过的对照实验的思想方法。我们可以让在 <strong><em>NEMU</em></strong> 中执行的每条指令也在真机中执行一次, 然后对比 <strong><em>NEMU</em></strong> 和真机的状态, 如果 <strong><em>NEMU</em></strong> 和真机的状态不一致, 我们就捕捉到 <strong><em>error</em></strong> 了!</p><p>这实际上是一种非常奏效的测试方法, 在软件测试领域称为 <strong><em>differential testing</em></strong> (后续简称 <strong><em>difftest</em></strong> )。通常来说, 进行 <strong><em>difftest</em></strong> 需要提供一个和 <strong><em>DUT(Design Under Test, 测试对象)</em></strong> 功能相同但实现方式不同的 <strong><em>REF(Reference, 参考实现)</em></strong> , 然后让它们接受相同的有定义的输入, 观测它们的行为是否相同。</p><p>而关于 <strong><em>REF</em></strong> ，我选择的是 <strong><em>Spike</em></strong>。<strong><em>Spike</em></strong> 是 <strong><em>RISC-V</em></strong> 社区的一款全系统模拟器, 它的工作原理与 <strong><em>NEMU</em></strong> 非常类似。我们可以信赖它的实现是正确的。</p><p>实现 <strong><em>difftest</em></strong> 也非常简单，框架代码已经帮我们完成了大部分工作。我只需要阅读源码，保证寄存器按照某种顺序排列，然后在 <strong><em>isa_difftest_checkregs()</em></strong> 中添加非常少量的的代码就可以得到一款无比强大的工具。天底下大概没有比这更赚的事情了。</p><div class="note primary modern"><p>你可以 <strong><em>RTFSC</em></strong> 或者直接去读 <strong><em>Spike</em></strong> 的手册，你很容易就能发现我们的 <strong><em>pa</em></strong> 框架本身就已经按照特定顺序排好了寄存器（如果你之前没有更改过寄存器顺序的话）。</p></div><div class="note primary modern"><p>在 <strong><em>isa_difftest_checkregs()</em></strong> 中我们只需要把 <strong><em>REF</em></strong> 和 <strong><em>DUT</em></strong> 的寄存器和 <strong><em>pc</em></strong> 值比较一下就行了，如果有不同直接返回 <strong><em>false</em></strong>。</p></div><p>在得到了 <strong><em>difftest</em></strong> 这个强大的工具后，赶紧再去测一下你的 <strong><em>cpu-tests</em></strong> 吧。如果你的程序被 <strong><em>difftest</em></strong> 拒绝了，那么你应该庆幸才对。我们在 <strong><em>bug</em></strong> 还未成气候之前就把它扼杀掉了，真是不幸中的万幸啊。</p><h1 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h1><p>这部分可谓是我做 <strong><em>PA</em></strong> 到现在最为震撼的部分，在这里面我们很快就能领略到软件层（<strong><em>AM</em></strong>）和硬件（<strong><em>NEMU</em></strong>）是如何紧密配合的，并且不得不感叹抽象是多么伟大且美丽的思想。</p><h2 id="串口"><a href="#串口" class="headerlink" title="串口"></a>串口</h2><p>串口是最简单的输出设备. <strong><em>nemu/src/device/serial.c</em></strong> 模拟了串口的功能. 其大部分功能也被简化, 只保留了数据寄存器. 串口初始化时会分别注册 <strong><em>0x3F8</em></strong> 处长度为 <strong><em>8个字节</em></strong> 的端口, 以及 <strong><em>0xa00003F8</em></strong> 处长度为 <strong><em>8字节</em></strong> 的 <strong><em>MMIO</em></strong> 空间, 它们都会映射到串口的数据寄存器。</p><p><strong><em>abstract-machine/am/src/platform/nemu/trm.c</em></strong> 中的 <strong><em>putch()</em></strong> 会将字符输出到串口。</p><p>因此实现 <strong><em>printf()</em></strong> 其实很简单，我们可以调用我们之前实现过的 <strong><em>vsprintf()</em></strong> 来实现解耦，然后把 <strong><em>buf</em></strong> 里的字节用 <strong><em>putch</em></strong> 输出即可。</p><h2 id="时钟（精华所在）"><a href="#时钟（精华所在）" class="headerlink" title="时钟（精华所在）"></a>时钟（精华所在）</h2><p>这一部分的实验代码设计的非常巧妙，这里我就不再介绍前情，直接进入正题。</p><h3 id="时钟的更新逻辑是什么？"><a href="#时钟的更新逻辑是什么？" class="headerlink" title="时钟的更新逻辑是什么？"></a>时钟的更新逻辑是什么？</h3><p>如果你仔细地 <strong><em>RTFSC</em></strong> 了之后就会知道，时钟更新的逻辑其实是由一个回调函数来控制的。而针对时钟来说，这个回调函数具体的就是 <strong><em>rtc_io_handler()</em></strong> 。当且仅当我们读取 <strong><em>RTC_ADDR</em></strong> 这个地址的高位的时候，我们才会触发时钟的更新逻辑。如果你没看懂我在说什么，建议回去再仔细研究一下源码，因为这对于我们读取到正确的时间非常重要。不然当后面做    <strong><em>benchmarks</em></strong> 的时候，你很可能无法得到预期的结果。<strong><em>PA</em></strong> 代码之所以这样设置，就是强迫我们去阅读源码，如果你没有弄清楚更新逻辑而胡乱读取一通，会有很大概率被坑到不行。</p><h3 id="inl-的魔力是如何实现的？"><a href="#inl-的魔力是如何实现的？" class="headerlink" title="inl() 的魔力是如何实现的？"></a>inl() 的魔力是如何实现的？</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inl() 的定义</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">uint32_t</span> <span class="title function_">inl</span><span class="params">(<span class="type">uintptr_t</span> addr)</span> &#123; <span class="keyword">return</span> *(<span class="keyword">volatile</span> <span class="type">uint32_t</span> *)addr; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取时钟这个设备来获取时间</span></span><br><span class="line">inl(RTC_ADDR);</span><br></pre></td></tr></table></figure><p>难道你就没有疑惑过吗？当我们写下这行代码的时候，我们到底是如何调用到时钟的回调函数的呢？明明我追踪到 <strong><em>inl()</em></strong> 的定义，他不过只是一个简单的解引用的包装罢了，根本就没有调用 <strong><em>rtc_io_handler()</em></strong> 的痕迹，何其怪哉。在揭晓答案之前，请让我们先赞美抽象，正是抽象把这一切都串联了起来。</p><p>让我们先回想一下对于 <strong><em>软件（AM）</em></strong> 来说一条解引用语句的执行过程。一条解引用的 <strong><em>C代码</em></strong> 被翻译成汇编后其实就是一条 <strong><em>load</em></strong> 指令，<strong><em>load</em></strong> 汇编指令有其对应的机器码，机器码会被装载进 <strong><em>硬件（NEMU）</em></strong> 中，进行译码和执行。。。 等等！这不是前不久我们一直在做的事吗？是的，就是你想的那样。那么 <strong><em>load</em></strong> 指令会调用什么呢？你应该去找指令执行函数了。到最后的最后，我们会追踪到一个叫 <strong><em>paddr_read()</em></strong> 的函数，里面有一个神奇的调用 <strong><em>mmio_read()</em></strong> 。一切的答案都在里面了。</p><p>你最终会发现，通过一个简单的 <strong><em>inl()</em></strong> 函数，是真的能调用到 <strong><em>rtc_io_handler()</em></strong> 的！这简直是太酷了！而实现这一切的原理并不复杂，其实就是 <strong><em>MMIO</em></strong>，将设备映射到内存上，我们对设备的访存也就被抽象成了对内存的访存，就跟我们访问其他普通内存看起来一样，让用户完全感觉不到差异。</p><p>让我们再回过头来看一遍我们是如何读取时钟这个设备的：<strong><em>inl(RTC_ADDR) ;</em></strong> </p><p><strong><em>多么简洁而有力啊！</em></strong></p><h3 id="看看NEMU跑多快"><a href="#看看NEMU跑多快" class="headerlink" title="看看NEMU跑多快"></a>看看NEMU跑多快</h3><p>有了时钟之后, 我们就可以测试一个程序跑多快, 从而测试计算机的性能。这里我统一只展示在 <strong><em>ref测试集</em></strong> 下所获得的分数。</p><ul><li><strong><em>dhrystone ：</em></strong><br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/G259JJ05]}DB{UMA5O5IRSS.png" alt=""></li><li><strong><em>coremark ：</em></strong><br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/core.png" alt=""></li><li><strong><em>microbench ：</em></strong><br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/microbench.png" alt=""></li></ul><h2 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h2><p>如果你真正弄懂了时钟，这个对你来说应该不是问题。如果你束手无策，那么你也不应该继续往下做了，好好回去把时钟弄懂吧。</p><h2 id="VGA"><a href="#VGA" class="headerlink" title="VGA"></a>VGA</h2><p><strong><em>VGA</em></strong> 的第一部分跟时钟其实是如出一辙的。重点是找到那两个隐藏起来的寄存器到底在哪里，至于是在哪里找，反正我是知道肯定是去 <strong><em>硬件（NEMU）</em></strong> 里找，而不是在 <strong><em>软件（AM）</em></strong> 里抓瞎，等着他们自己出现。这里再提示一个关键词 <strong><em>vgactl_port_base</em></strong>，剩下的就靠你自己了。</p><p><strong><em>VGA</em></strong> 的第二部分才是重量级。关于图形绘制这块的逻辑非常之重要，一定要彻底掌握。不然到后面的 <strong><em>PA3</em></strong> 将无比痛苦。讲义已经告诉我们了，在第一部分看到的青绿色条纹画面其实并不是正确的 <strong><em>display test</em></strong> 期望的输出画面。</p><p>原因是 <strong><em>AM_GPU_FBDRAW</em></strong> 没能正确实现，也就是说我们还没有正确把 <strong><em>帧缓冲寄存器</em></strong> 中的数据更新到 <strong><em>显存</em></strong> 中。具体是在哪里更新，只要你认真地读了 <strong><em>gpu.c</em></strong> 中的函数的名字，应该就非常显然了。俗话说好的取名就是最佳的注释，这句话可不是嘴上说说的。</p><p>别忘了讲义中提醒我要好好看看 <strong><em>display test</em></strong> 的源码，别偷懒，这对我们理解软件是如何更新画面的逻辑是有很大帮助的。如果你读了源码之后就会发现，其实 <strong><em>display test</em></strong> 的更新逻辑并非一次全部写入的，而是将整个 <strong><em>400 </em> 300*</strong> 的屏幕分成了很多个小矩形块，每次写入一个小矩形块到显存中进行更新的。</p><p>请注意这里的 <strong><em>400 </em> 300*</strong> ，这里是以像素为单位的屏幕长宽，我之前就是理解错了这里，才没能明白 <strong><em>display test</em></strong> 中 <strong><em>W / N</em></strong> 的含义。什么是像素，这里你可以理解为一个32位大小的描述颜色的字节块，这个字节块的大小为 <strong><em>4个字节</em></strong> ，以 <strong><em>00RRGGBB</em></strong> 这样的形式来描述颜色。所以说 <strong><em>400 </em> 300*</strong> 的屏幕大小在内存中所占的大小就为 <strong><em>400 </em> 300 <em> 4</em></strong> 个字节。后面我在绘制的时候，默认的单位都是像素，而不是字节。</p><p>阅读 <strong><em>display test</em></strong> 就能知道，当一个矩形块的数据准备好后，用户程序就会调用 <strong><em>AM</em></strong> 提供的 <strong><em>io_write()</em></strong> 接口，只要你一路追踪，最后就会来到正确更新显存的地方。现在我们的 <strong><em>帧缓冲寄存器</em></strong> 中已经有了用户程序传过来的矩形块的颜色信息了，我们要做的就是把这个矩形块绘制到屏幕上正确的坐标上。其实你已经注意到了，<strong><em>ctl</em></strong> 中的 <strong><em>pixels</em></strong> 是一个一维数组，而我们要根据用户程序传过来的 <strong><em>w</em></strong> 和 <strong><em>h</em></strong> 将它还原成二维数组，这样我们才能正确地完成绘画。</p><p>这一部分光说还是有点太抽象了，我这里画了一张图，希望能帮助大家更好理解：<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/`4[{SHB}GGYOJZ774}9AILH.png" alt=""></p><p>对着图说就爽多了。所以我们在用一维数组 <strong><em>pixels</em></strong> 绘制的时候不只要考虑矩形块本身的行优先问题，还要考虑屏幕本身的行优先问题，还要考虑 <strong><em>（x，y）</em></strong> 起始坐标的初始 <strong><em>offset</em></strong> 问题。计算机绘图，很奇妙吧（笑）。如果你开始没考虑清楚这其中的逻辑关系，没有关系，多想想这张图，相信你自己一定能调对的。</p><p>偶对了，说了半天，还没说到底怎么把 <strong><em>帧缓冲寄存器</em></strong> 中的数据更新到 <strong><em>显存</em></strong> 中。讲义第一部分给出的测试代码已经给出了解答：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> *fb = (<span class="type">uint32_t</span> *)(<span class="type">uintptr_t</span>)FB_ADDR;</span><br></pre></td></tr></table></figure><br>这是什么意思捏？我相信这肯定难不倒你了。</p><p>这里再提一嘴我遇到的一个小坑，<strong><em>gpu.c</em></strong> 中的每个函数都有其存在的意义，请确保自己弄明白了每个函数的使命是什么，以及他们是否被设置在了正确的状态。</p><h3 id="展示VGA"><a href="#展示VGA" class="headerlink" title="展示VGA"></a>展示VGA</h3><p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/vga.png" alt=""></p><h3 id="在NEMU上运行Mario"><a href="#在NEMU上运行Mario" class="headerlink" title="在NEMU上运行Mario"></a>在NEMU上运行Mario</h3><p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/`}OH5(7OFZ0XMI8BW9G_ZTB.png" alt=""></p><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p><a href="https://nju-projectn.github.io/ics-pa-gitbook/ics2021/index.html"><strong><em>https://nju-projectn.github.io/ics-pa-gitbook/ics2021/index.html</em></strong></a></p>]]></content>
      
      
      <categories>
          
          <category> PA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C和C++中的inline</title>
      <link href="/archives/6aa13749.html"/>
      <url>/archives/6aa13749.html</url>
      
        <content type="html"><![CDATA[<p>inline是C和C++中都有的关键字，虽然名字一样，但在一些细节上还是有些许不同的。虽然网络上关于inline的讨论可谓是络绎不绝，但其中某些错误认知可谓是深入人心（bushi）。因此，本文尝试对其中的主要观点进行说明和验证。</p><h2 id="0x1-C和C-中的inline一样吗"><a href="#0x1-C和C-中的inline一样吗" class="headerlink" title="0x1. C和C++中的inline一样吗?"></a>0x1. C和C++中的inline一样吗?</h2><h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>答案是不完全一样。</p><p>C语言中inline函数一般都是定义在头文件中，但请注意，此定义只是提供了一个内联版本，因此，该定义也被称为 <em><strong>内联定义</strong></em> 。C编译器并不会自动为我们提供非内联版本，需要我们在某一个.c文件中提供常规的非 <strong>inline</strong> 非 <strong>static</strong> 函数，或是声明为 <strong>extern inline</strong> 的函数，则此定义也被称作 <em><strong>外部定义</strong></em> 。如果不提供，则会在链接阶段发生报错，因为 <em><strong>内联定义</strong></em> 不会被放入符号表中，在链接时无法找到已经编译好的test函数，所以发生了链接错误。</p><p>此行为已经在C99标准规定了：</p><blockquote><p>引用自<a href="https://zh.cppreference.com/w/c/language/inline"><em><strong>cppreference.com</strong></em></a><br><em><strong>——为避免未定义行为，若在表达式中使用拥有外部链接的函数名，则程序中必须存在一个外部定义，见一个定义规则。</strong></em> </p></blockquote><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子 1"></a>例子 1</h3><p>这里我们给出例子，我使用的是 <strong>Debian</strong> 下的 <strong>gcc 10.2.1</strong>，优化等级限定在 <strong>O0</strong>。</p><p>test.h:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TEST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TEST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;test!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>main.c:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[], <span class="type">const</span> <span class="type">char</span> *envp[])</span> </span><br><span class="line">&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行编译，得到了一个链接错误，提示 <strong>‘test’</strong> 符号没有找到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">anya@debian:~/OSwork/test-code$ gcc --version</span><br><span class="line">gcc (Debian 10.2.1-6) 10.2.1 20210110</span><br><span class="line">Copyright (C) 2020 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line"></span><br><span class="line">anya@debian:~/OSwork/test-code$ gcc main.c -o main &amp;&amp; ./main</span><br><span class="line">/usr/bin/ld: /tmp/cc3k3H5m.o: in function `main&#x27;:</span><br><span class="line">main.c:(.text+0x19): undefined reference to `test&#x27;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br></pre></td></tr></table></figure><p>为了解决这个问题也很简单，在 main.c 中加上外部定义即可：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[], <span class="type">const</span> <span class="type">char</span> *envp[])</span> </span><br><span class="line">&#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">anya@debian:~/OSwork/test-code$ gcc main.c -o main &amp;&amp; ./main</span><br><span class="line">test!</span><br></pre></td></tr></table></figure><h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子 2"></a>例子 2</h3><p><em><strong>而对于C++来说，同一份包含 inline 函数的代码，即使不加外部定义，只需要把后缀从.c改成.cpp，就可以解决链接问题。</strong></em> </p><p>这里我们只是简单地修改了文件后缀名，使用同样的编译器和优化等级。</p><p>test.h:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TEST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TEST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;test!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>main.cpp:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[], <span class="type">const</span> <span class="type">char</span> *envp[])</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">anya@debian:~/OSwork/test-code$ g++ main.cpp -o main &amp;&amp; ./main</span><br><span class="line">test!</span><br></pre></td></tr></table></figure><p>到这里，其实我们就已经完成了证明，C++和C中的inline确实是不一样的，<em><strong>讨论   inline 关键字时，应该区分C语言和C++分别讨论。</strong></em></p><p>至于为什么改成.cpp后就消除了链接错误，如果要展开来说又是一番长篇大论。</p><p>简单来说，就是inline定义会在所有用到该函数但没有内联的.cpp中隐式实例化非内联版本。</p><p>如果你想要十分确切的理论依据，可以参考标准的解释：</p><blockquote><p>引用自<a href="https://zh.cppreference.com/w/cpp/language/inline"><em><strong>cppreference.com</strong></em></a><br><em><strong>——函数与变量 (C++17 起)的 inline 说明符</strong></em></p></blockquote><h2 id="0x2-inline在现代编译器里相当于弱符号指示符吗"><a href="#0x2-inline在现代编译器里相当于弱符号指示符吗" class="headerlink" title="0x2. inline在现代编译器里相当于弱符号指示符吗?"></a>0x2. inline在现代编译器里相当于弱符号指示符吗?</h2><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>在编译时，编译器向汇编器输出每个全局符号，或者是 <em><strong>强（strong）</strong></em>或者是 <em><strong>弱（weak）</strong></em>，而汇编器把这个信息隐含地编码在可重定位目标文件的符号表里。<br>根据强弱符号的定义，Linux链接器使用下面的规则来处理多重定义的符号名。</p><ul><li>规则1：不允许有多个同名的强符号。</li><li>规则2：如果有一个强符号和多个弱符号同名，那么选择强符号。</li><li>规则3：如果有多个弱符号同名，那么从这些弱符号中任意选择一个。</li></ul><h3 id="正文-1"><a href="#正文-1" class="headerlink" title="正文"></a>正文</h3><p>当多个翻译单元（.cpp）都出现了同名内联函数（这里为了简单，排除了重载和模板的情况）的定义时，我们的链接器会如何选择呢？inline会让这些同名函数成为弱符号吗？<em><strong>答案是不同编译器的行为不一样，Linux gcc下确实是弱符号，而 Windows msvc却是强符号</strong></em>。所以inline是弱符号指示符是不完全正确的。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>首先考虑Linux gcc下的情况：</p><p>test.h:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TEST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TEST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;test!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>main.cpp:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;test.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> *argv[], <span class="type">const</span> <span class="type">char</span> *envp[])</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译和符号表结果如下，<em><strong>W</strong></em>表示全局弱符号，说明inline修饰起到了弱符号指示符的作用：</p><p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/nm.png"></p><p>同样的代码我们不加更改，在 Windows 下我们使用 vs2019 自带的 msvc 编译器，同样是编译后查看符号，发现 test 内联函数对应的符号并不是弱符号 <em><strong>W</strong></em> ，而是全局符号 <em><strong>T</strong></em>：</p><p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/msvc-nm.png"></p><h2 id="0x3-现代编译器里对-inline-关键字的内联建议是否采用"><a href="#0x3-现代编译器里对-inline-关键字的内联建议是否采用" class="headerlink" title="0x3. 现代编译器里对 inline 关键字的内联建议是否采用"></a>0x3. 现代编译器里对 inline 关键字的内联建议是否采用</h2><p>inline 关键词的本意是作为给优化器的指示器，以指示优先采用函数的内联替换而非进行函数调用，即并不执行将控制转移到函数体内的函数调用 CPU 指令，而是代之以执行函数体的一份副本而无需生成调用。这会避免函数调用的开销（传递实参及返回结果），但它可能导致更大的可执行文件，因为函数体必须被复制多次。</p><p>但在 C++17 以后，inline 对于函数的含义已经变为“容许多次定义”而不是“优先内联”。那么现代 CPP 编译器对于一个 inline 函数是否采取内联，其实就比较看心情了，因为标准中也没有强制 inline 函数一定要产生内联。但对于编译器具体的行为如何，我们可以通过一个方便的网站来直接查看：<a href="https://gcc.godbolt.org/"><em><strong>https://gcc.godbolt.org/</strong></em></a></p><h3 id="例子-1-1"><a href="#例子-1-1" class="headerlink" title="例子 1"></a>例子 1</h3><p>对于一个十分 trivial 的 <code>inline int add(int a, int b);</code> 函数，理论上他是具备内联的条件的。我在三大主流的 C++ 编译器上都进行了测试，优化参数都选择的是 -O0，其结果如下：<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221027195123.png"></p><p>可以看到，在 -O0 的优化下，三大编译器都没有选择进行内联优化。当优化等级更高时，即使不用 inline 关键词 <code>inline int add(int a, int b);</code> 函数也会被优化掉：<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/QQ%E5%9B%BE%E7%89%8720221027195524.png"></p><p>因此，对于 C++ 来说，我们不建议对于 inline 关键词的 “优先内联” 作用抱有太大期待，而是应该将认知转向自 C++17 后 inline 关键词被赋予的 “容许多次定义” 含义。</p><h2 id="0x4-小结"><a href="#0x4-小结" class="headerlink" title="0x4 小结"></a>0x4 小结</h2><p>本文通过引用<a href="https://zh.cppreference.com/w/cpp/language/inline"><em><strong>cppreference.com</strong></em></a>中关于标准的阐述，并结合实际的代码，在不同平台和编译器上进行验证，得到一些结论：</p><ol><li>C 的 inline 和 C++ 的 inline 不一样，尽管 C 的 inline 是借鉴的 C++</li><li>多个翻译单元中的同名非 static 的 inline 函数，可能被当做全局弱符号，也可能是全局强符号</li><li>现代 C++ 编译器对于一个 inline 函数是否展开，从标准到实现上都是没有保证的，即使是一个十分 trivial 的函数</li></ol>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C和C++中的inline </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令</title>
      <link href="/archives/caff8000.html"/>
      <url>/archives/caff8000.html</url>
      
        <content type="html"><![CDATA[<h2 id="初始化本地仓库"><a href="#初始化本地仓库" class="headerlink" title="初始化本地仓库"></a>初始化本地仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; git init</span><br></pre></td></tr></table></figure><h2 id="确认工作树和索引的状态"><a href="#确认工作树和索引的状态" class="headerlink" title="确认工作树和索引的状态"></a>确认工作树和索引的状态</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; git status</span><br></pre></td></tr></table></figure><h2 id="将文件添加到暂存区"><a href="#将文件添加到暂存区" class="headerlink" title="将文件添加到暂存区"></a>将文件添加到暂存区</h2><p>在 [file] 指定加入暂存区的文件, 用空格分隔多个文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; git add [file]..</span><br><span class="line"><span class="comment">## e.g.</span></span><br><span class="line">&gt;&gt; git add README.md</span><br><span class="line">&gt;&gt; git add README.md main.cpp</span><br></pre></td></tr></table></figure><h2 id="将所有新文件、更改过的文件添加到暂存区"><a href="#将所有新文件、更改过的文件添加到暂存区" class="headerlink" title="将所有新文件、更改过的文件添加到暂存区"></a>将所有新文件、更改过的文件添加到暂存区</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; git add .</span><br></pre></td></tr></table></figure><h2 id="提交更改-将暂存区内容添加到本地仓库中"><a href="#提交更改-将暂存区内容添加到本地仓库中" class="headerlink" title="提交更改, 将暂存区内容添加到本地仓库中"></a>提交更改, 将暂存区内容添加到本地仓库中</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; git commit -m <span class="string">&quot;first commit&quot;</span></span><br></pre></td></tr></table></figure><h2 id="查看更改日志"><a href="#查看更改日志" class="headerlink" title="查看更改日志"></a>查看更改日志</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><h2 id="添加一个远程存储库"><a href="#添加一个远程存储库" class="headerlink" title="添加一个远程存储库"></a>添加一个远程存储库</h2><p>请使用remote指令添加远程数据库。在 [name] 处输入远程数据库名称，在 [url] 处指定远程数据库的URL。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; git remote add [name] [url]</span><br><span class="line"><span class="comment">## e.g.</span></span><br><span class="line">&gt;&gt; git remote add origin https://[space_id].backlogtool.com/git/[project_key]/tutorial.git</span><br></pre></td></tr></table></figure><blockquote><p><em><strong>tips:</strong></em> 执行推送或者拉取的时候，如果省略了远程数据库的名称，则默认使用名为”origin“的远程数据库。因此一般都会把远程数据库命名为origin。</p></blockquote><h2 id="将分支推送到你的远程存储库"><a href="#将分支推送到你的远程存储库" class="headerlink" title="将分支推送到你的远程存储库"></a>将分支推送到你的远程存储库</h2><p>[remote-name&#x3D;origin] 处输入目标地址，[branch-name] 处指定推送的分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; git push [remote-name=origin] [branch-name]</span><br><span class="line"><span class="comment">## e.g.</span></span><br><span class="line">&gt;&gt; git push -u origin master</span><br></pre></td></tr></table></figure><blockquote><p><em><strong>tips:</strong></em> 运行以下命令便可向远程数据库‘origin’进行推送。当执行命令时，如果您指定了-u选项，那么下一次推送时就可以省略分支名称了。但是，首次运行指令向空的远程数据库推送时，必须指定远程数据库名称和分支名称。</p></blockquote><h2 id="拷贝Git仓库到本地"><a href="#拷贝Git仓库到本地" class="headerlink" title="拷贝Git仓库到本地"></a>拷贝Git仓库到本地</h2><p>在 [repository] 指定远程数据库的URL，在 [directory] 指定新目录的名称。[directory] 可省略不写，则默认 clone 到当前目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; git <span class="built_in">clone</span> [repository] [directory]</span><br><span class="line"><span class="comment">## e.g.</span></span><br><span class="line">&gt;&gt; git <span class="built_in">clone</span> https://github.com/Anyacoding/AnyaSTL.git myblog</span><br></pre></td></tr></table></figure><h2 id="从远程存储库中拉取更改"><a href="#从远程存储库中拉取更改" class="headerlink" title="从远程存储库中拉取更改"></a>从远程存储库中拉取更改</h2><p>使用pull指令进行拉取操作。省略数据库名称的话，会在名为origin的数据库进行pull。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; git pull [repository] [branch-name]</span><br><span class="line"><span class="comment">## e.g.</span></span><br><span class="line">&gt;&gt; git pull origin master</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git常用命令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序</title>
      <link href="/archives/bb0c7ac5.html"/>
      <url>/archives/bb0c7ac5.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>想起很久之前曾在Leetcode刷到过一道很经典的归并排序的题目，虽然题目不难，但实现起来并没有想象中那么容易。为了方便日后查阅，在这里特地记录一下</p><h2 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p><p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p><ul><li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</li><li>自下而上的迭代；</li></ul><p>为了代码的简洁，我这里采用的是递归的写法。</p><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><blockquote><p><em><strong>首先感谢<a href="https://www.cnblogs.com/chengxiao/p/6194356.html">图解排序算法(四)之归并排序</a>这篇文章的作者，对于归并排序的流程他完成了几幅很精美简洁的流程图，在这里分享给大家</strong></em></p></blockquote><p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/202207042134907.png"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r, vector&lt;<span class="type">int</span>&gt;&amp; temp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l + <span class="number">1</span> &gt;= r) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// divide</span></span><br><span class="line">    <span class="type">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(nums, l, m, temp);</span><br><span class="line">    <span class="built_in">merge_sort</span>(nums, m, r, temp);</span><br><span class="line">    <span class="comment">// conquer</span></span><br><span class="line">    <span class="type">int</span> p = l, q = m, i = l;</span><br><span class="line">    <span class="keyword">while</span> (p &lt; m || q &lt; r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q &gt;= r || (p &lt; m &amp;&amp; nums[p] &lt;= nums[q])) &#123;</span><br><span class="line">            temp[i++] = nums[p++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            temp[i++] = nums[q++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = l; i &lt; r; ++i) &#123;</span><br><span class="line">        nums[i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实战指路"><a href="#实战指路" class="headerlink" title="实战指路"></a>实战指路</h2><blockquote><p><a href="https://leetcode-cn.com/problems/sort-list/"><em><strong>Leetcode 148. Sort List (Medium)</strong></em></a></p></blockquote><p>“<em><strong>学会一种算法的最好方法就是去使用它。</strong></em>“<br><em><strong>Get your hand dirty！</strong></em></p><p>这里给出我的实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> ListNode* List;</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mergesort</span>(head);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">List <span class="title">mergesort</span><span class="params">(List head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果第一或第二个结点是空结点，则不用归并，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        List fast, slow, fasttp, l, r;<span class="comment">//设定快慢指针来找中间结点；</span></span><br><span class="line">        fast = slow = head;</span><br><span class="line">        fasttp = head-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (fasttp != <span class="literal">NULL</span> &amp;&amp; fasttp-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fasttp = fasttp-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时slow-&gt;next即为中间结点</span></span><br><span class="line">        <span class="comment">//对右边进行归并</span></span><br><span class="line">        r = <span class="built_in">mergesort</span>(slow-&gt;next);</span><br><span class="line">        <span class="comment">//一个链表结束的标志是nullptr，所以这里进行cut操作，否则会出现一个循环的死</span></span><br><span class="line">        slow-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        l = <span class="built_in">mergesort</span>(head);</span><br><span class="line">        <span class="comment">//最后将左右两段进行一个合并</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(l, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">List <span class="title">merge</span><span class="params">(List l, List r)</span> </span>&#123;</span><br><span class="line">        List temphead = <span class="keyword">new</span> ListNode;</span><br><span class="line">        List p = temphead;</span><br><span class="line">        <span class="keyword">while</span> (l &amp;&amp; r) &#123;</span><br><span class="line">            <span class="keyword">if</span>(l-&gt;val &lt;= r-&gt;val) &#123;</span><br><span class="line">                p-&gt;next = l;</span><br><span class="line">                l = l-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p-&gt;next = r;</span><br><span class="line">                r = r-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当左边有剩余时</span></span><br><span class="line">        <span class="keyword">if</span> (l != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            p-&gt;next = l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当右边有剩余时</span></span><br><span class="line">        <span class="keyword">if</span> (r != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            p-&gt;next = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temphead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++内存对齐问题</title>
      <link href="/archives/af823184.html"/>
      <url>/archives/af823184.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天热心(huaidan)群友在群里出了这样一个问题: <mark class="hl-label pink">请推测出下列代码的输出，在32位系统下.</mark> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> a = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    <span class="built_in">myclass</span>(): arr&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, <span class="built_in">p</span>(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">2</span>]) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">myclass</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    myclass obj; </span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(obj.arr) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(obj.p) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(obj);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我的答案是12 4 25，嘿嘿，我还信心满满的捏。因为我已经注意到了要把虚函数表隐含的那根指针算进去。然而我还是被坑了。</p><mark class="hl-label pink">正确答案如下:</mark> <p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/202207042134912.png"><br>前两个没什么好说的，主要是第三个输出。28是这么来的：<em><strong>28 &#x3D; vptr4 + f4 + c4 + arr12 + p4</strong></em></p><p>如果你没有接下来将要介绍的知识，估计你也会疑惑，为什么char的大小不是1字节而是4字节呢？如果char在这里的大小为1字节，结果将是我所预测的25。</p><p>然而事实却是，一个结构体或类定义完后，其在内存中的存储并不等于其所包含的元素的宽度之和。<br>这就是<em><strong>内存对齐问题</strong></em></p><p>首先感谢<a href="https://blog.csdn.net/liukun321/article/details/6974282">结构体在内存中的对齐规则 - 咕唧咕唧shubo.lk的专栏 - 博客频道 - CSDN.NET</a>这篇文章的作者，正是通过他的博客，我才真正弄懂了内存对齐问题</p><h2 id="原则一"><a href="#原则一" class="headerlink" title="原则一"></a>原则一</h2><p><em><strong>结构体中元素是按照定义顺序一个一个放到内存中去的，但并不是紧密排列的。从结构体存储的首地址开始，每一个元素放置到内存中时，它都会认为内存是以它自己的大小来划分的，因此元素放置的位置一定会在自己宽度的整数倍上开始（以结构体变量首地址为0计算）。</strong></em></p><p>比如我们上面举的例子，首先系统会将虚函数表指针放入第0-3个字节(这里指的时相对地址，即内存开辟的首地址)，这里是另外一个知识了，<em><strong>若一个类中有虚函数，那么他的虚函数表指针将放在类的开头</strong></em>；然后在存放float型变量时，会以4个字节为单位进行存储，也就是在第4-7个字节；然后是放入char型变量，每个char以1个字节为单位进行存储，也就是放在第8个字节；然后是放入int型数组，这个数组有3个元素，也就是将要放入3个int，每个int以4个字节为单位进行存储，由于前三个四字节模块已经有数据，所以这个数组会被存放在第12-23个字节；最后是指针p，在32位系统下指针的宽度为4个字节，所以他会被放在第24-27个字节。</p><mark class="hl-label pink">整体存储示意图如下所示:</mark> <p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/202207042134914.png"><br>到这里还没完，让我们试着把float改成double试试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myclass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> a = <span class="number">1.0f</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>];</span><br><span class="line">    <span class="type">int</span> *p;</span><br><span class="line">    <span class="built_in">myclass</span>(): arr&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, <span class="built_in">p</span>(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">2</span>]) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">myclass</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> [] p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    myclass obj; </span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(obj.arr) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(obj.p) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(obj);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了上面介绍的原则一，我们不难算出obj的大小为 <em><strong>36 &#x3D; 8 + 8 + 4 + 12 + 4</strong></em>，和上面计算过程中唯一的区别是我们的虚函数表指针由于double的对齐问题，被看作了一个8字节大小的单元。</p><p>然而事实却不是这样。<br><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/202207042134913.png"><br>而这就引出了我们的第二原则。</p><h2 id="原则二"><a href="#原则二" class="headerlink" title="原则二"></a>原则二</h2><p><em><strong>在经过第一原则分析后，检查计算出的存储单元是否为所有元素中最宽的元素的长度的整数倍，是，则结束；若不是，则补齐为它的整数倍。</strong></em></p><p>在上面这个例子中，我们分析完后的存储长度为36字节，不是最宽元素double长度的整数倍，因此将36补齐到8的整数倍，也就是40。这样就没问题了。</p><mark class="hl-label pink">其存储示意图如下所示:</mark> <p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/202207042134915.png"><br>掌握了这两个原则，就足以分析所有数据存储的对齐问题了。快去找几个例子试试吧！</p><hr><p>这里进行一个补充：由于static成员并不属于类的实例对象，所以在计算的时候请注意不要把static成员考虑进来捏~</p>]]></content>
      
      
      <categories>
          
          <category> C/C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++内存对齐问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于C语言scanf函数吃人事件</title>
      <link href="/archives/66d72fbf.html"/>
      <url>/archives/66d72fbf.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大一的时候刚刚接触c语言，使用scanf函数总是会莫名出现各种奇怪的输入问题，想想还真是踩了很多坑捏呜呜。例如输入数据时，会发现若%d后面加了空格之后按下回车键控制台没有响应，这其实就是吃空白行为。</p><p>给变量赋值实际上需要从缓冲区提取合适的数据到变量中，而缓冲区的数据其实是由我们的键盘来输入的。</p><mark class="hl-label pink">举个例子:</mark> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;x = %d\ny = %d&quot;</span>, x, y);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面这段代码，我们可以有两种输入方法。一种是输入x的值，然后空格，然后输入y的值</p><p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/KMI5DOV4BC08U4XH.png"></p><p>另一种是输入x的值，回车，然后输入y的值</p><p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/T_6PKH61Z9A@FP7SYO5RO.png"></p><p>不难发现，其实两种输入方式的回车和空格都没有被输入到y中，这是我们所期望的。这是因为%d的匹配机制，会不断丢弃空白符(<mark class="hl-label pink">包括回车，空白等</mark> )，直到出现数字字符，然后scanf开始解析数字字符串，再将解析好的数值存入到y中。至此一个%d的匹配工作完成，当然，最后结束输入的时候我们还按了一个回车，这个回车仍然留在缓冲区中没被处理。</p><p>通过上述的实验我们可以知道，%d会自动把缓冲区中数字字符串之前的空白符全部扔掉，也就是恰空白行为。</p><h2 id="关于-d无响应问题"><a href="#关于-d无响应问题" class="headerlink" title="关于%d无响应问题"></a>关于%d无响应问题</h2><p>由于作为一名c语言弱鸡，对于格式化的要求往往非常随意，我在使用%d时常常最后面错误地多加了一个空格，从而导致了输入无法正常结束。也就会发生经典剧情，“<mark class="hl-label pink">明明我们的代码一模一样，为什么我的就运行不了呜呜。</mark> ” 我们需要知道，当%d的匹配工作完成后，%d后面的空格开始工作，空格意味着丢掉所有空白符，因此无论我们输入多少个空格和回车，scanf都不会正常结束。要使scanf函数结束，我们需要输入一个非空白字符，来使得空格吃空白符的工作结束。</p><p>细心的同学应该发现了，其实我们最后输入的那个非空白符任然留在缓冲区中，没有被处理，在下次输入时就会被事与愿违地读取，我们来看这一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d &quot;</span>, &amp;x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x = %d\n&quot;</span>, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/628H_N7IKDHWOT8T.png"></p><p>不建议在%d后面加入空格捏</p><h2 id="吃空白的其他烹饪方式"><a href="#吃空白的其他烹饪方式" class="headerlink" title="吃空白的其他烹饪方式"></a>吃空白的其他烹饪方式</h2><p>由于%d本身就会吃掉整形数前面的所有空白符，所以在%d前面加不加空格都无所谓捏。但是对于字符%c来说情况就完全不同了，由于空白符本身也是一种字符，所以%c会错误地把多余地空格以及回车等东东读入捏。</p><p>我们看下面的一组例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span> y = <span class="string">&#x27;&#x27;;</span></span><br><span class="line"><span class="string">  scanf(&quot;%d&quot;, &amp;x);</span></span><br><span class="line"><span class="string">  scanf(&quot;%c&quot;, &amp;y);</span></span><br><span class="line"><span class="string">  printf(&quot;x = %d\ny = %c&quot;, x, y);</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/8NML31TBKRS@ILNK1M2X.png"></p><p>可以明显看到，留在缓冲区中的空格被y读取了。你可以去试试，输入x的值，回车，再输入y的值，缓冲区中的回车同样会被y读取。</p><p>为了达到我们想要的效果，我们可以在%c前面加一个空格，来把缓冲区中多余的空白符吃掉：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span> y = <span class="string">&#x27;&#x27;;</span></span><br><span class="line"><span class="string">  scanf(&quot;%d&quot;, &amp;x);</span></span><br><span class="line"><span class="string">  scanf(&quot; %c&quot;, &amp;y);</span></span><br><span class="line"><span class="string">  printf(&quot;x = %d\ny = %c&quot;, x, y);</span></span><br><span class="line"><span class="string">  return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/PDF0ELCJ7H08KQTBO7A.png"></p><p>我们得到了我们想要的效果。</p><p>因此，当我们的输入中不想错误地读取空白字符时，建议你在%c前面加上一个空格。</p><p>对于%s的处理方式，和%c非常相似。%s遇到空白符就会认为这个字符串输入完毕了，且这个空白符及其之后的输入仍然会留在缓冲区中。</p><p>上例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;请输入一串字符：&quot;</span>);</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;这个字符串为:%s\n&quot;</span>, str);</span><br><span class="line">  gets(str);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;这个字符串为:%s\n&quot;</span>, str);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://anya-1308928365.cos.ap-nanjing.myqcloud.com/blog/WIYCBKZND7_P1HRX.png"><br>这里我用gets函数把留在缓冲区中的内容全都取了出来，结果很显然了</p><p>对于scanf吃空白这一技巧，其实更多的是一种技术细节，比起死记硬背他的用法，更重要的是我们应该理解这背后的原理，这样方能以不变应万变</p>]]></content>
      
      
      <categories>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
